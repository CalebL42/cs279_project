files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "export function VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
            },
            "jest_test_file_headers": [
                "const { clientSideSanitization } = require('./index.js');",
                "const jsdom = require('jsdom');",
                "const { JSDOM } = jsdom;"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass sanitization with <img> tag in clientSideSanitization', () => {\n  const dom = new JSDOM('<!DOCTYPE html><html><body><div></div></body></html>');\n  const el = dom.window.document.querySelector('div');\n  const input = '<img src=\"javascript:alert(`xss`)\">';\n  const modifiers = { nothing: true }; // Incorrect application expected\n  clientSideSanitization(el, { modifiers, oldValue: '', value: input });\n\n  // Theoretical safe output, assuming complete tag stripping or escaping\n  // But failure shows the vulnerability\n  expect(el.innerHTML).toBe('&lt;img src=\"javascript:alert(`xss`)\"&gt;');\n});"
                },
                {
                    "signature_and_body": "test('dangerous <iframe> not stripped in clientSideSanitization', () => {\n  const dom = new JSDOM('<!DOCTYPE html><html><body><div></div></body></html>');\n  const el = dom.window.document.querySelector('div');\n  const input = '<iframe src=\"http://malicious.com\"></iframe>';\n  const modifiers = { basic: true };\n  clientSideSanitization(el, { modifiers, oldValue: '', value: input });\n\n  // Theoretical result expects <iframe> stripped\n  expect(el.innerHTML).toBe('');\n});"
                },
                {
                    "signature_and_body": "test('malicious href in <a> tag bypasses sanitization', () => {\n  const dom = new JSDOM('<!DOCTYPE html><html><body><div></div></body></html>');\n  const el = dom.window.document.querySelector('div');\n  const input = '<a href=\"javascript:alert(`xss`)\">Click here</a>';\n  const modifiers = { inline: true };\n  clientSideSanitization(el, { modifiers, oldValue: '', value: input });\n\n  // Expected output should have stripped the href attribute\n  expect(el.innerHTML).toBe('<a>Click here</a>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "function serverSideSanitization ({ modifiers, value })"
            },
            "jest_test_file_headers": [
                "const { serverSideSanitization } = require('./index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('serverSideSanitization leaves <script> tag unaltered', () => {\n  const input = '<script>alert(\"xss\")</script>';\n  const modifiers = { nothing: true }; // Applying the wrong filter\n  const result = serverSideSanitization({ modifiers, value: input });\n\n  // Expected sanitized content is fully stripped scripts\n  expect(result.innerHTML).toBe('&lt;script&gt;alert(\"xss\")&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('serverSideSanitization does not sanitize <img> tag', () => {\n  const input = '<img src=\"javascript:alert(`xss`)\">';\n  const modifiers = { inline: true }; // Where it should be stricter\n  const result = serverSideSanitization({ modifiers, value: input });\n\n  // Expected sanitized content is a stripped <img> tag\n  expect(result.innerHTML).toBe('');\n});"
                },
                {
                    "signature_and_body": "test('serverSideSanitization allows unsafe inline styles', () => {\n  const input = '<div style=\"position:absolute;top:0;left:0;width:100%;height:100%;\">You have been owned!</div>';\n  const modifiers = { basic: true };\n  const result = serverSideSanitization({ modifiers, value: input });\n\n  // Expected output should strip the style attribute entirely\n  expect(result.innerHTML).toBe('<div>You have been owned!</div>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "export function VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
            },
            "jest_test_file_headers": [
                "const { VueSanitizeDirectiveSSR } = require('./index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('VueSanitizeDirectiveSSR fails to remove <script> tag', () => {\n  const vnode = { data: { domProps: {} } };\n  const input = '<script>alert(\"xss\")</script>';\n  const modifiers = { nothing: true };\n  VueSanitizeDirectiveSSR(vnode, { modifiers, value: input });\n\n  // Expect the script tags to be escaped or removed\n  expect(vnode.data.domProps.innerHTML).toBe('&lt;script&gt;alert(\"xss\")&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('VueSanitizeDirectiveSSR does not strip <iframe> tags', () => {\n  const vnode = { data: { domProps: {} } };\n  const input = '<iframe src=\"http://malicious.com\"></iframe>';\n  const modifiers = { inline: true };\n  VueSanitizeDirectiveSSR(vnode, { modifiers, value: input });\n\n  expect(vnode.data.domProps.innerHTML).toBe(''); // Theoretical secure result\n});"
                },
                {
                    "signature_and_body": "test('VueSanitizeDirectiveSSR allows harmful <a> href', () => {\n  const vnode = { data: { domProps: {} } };\n  const input = '<a href=\"javascript:alert(`xss`)\" style=\"color:red\">Click me</a>';\n  const modifiers = { inline: true };\n  VueSanitizeDirectiveSSR(vnode, { modifiers, value: input });\n\n  // Expected to strip href but allow <a> tag with specific styling\n  expect(vnode.data.domProps.innerHTML).toBe('<a style=\"color:red\">Click me</a>');\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
            "function_name": "ajvSanitizer"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "text(data)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "ajvSanitizer"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./index');",
                "const assert = require('assert');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitization bypass with improperly escaped HTML', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'text'\n            }\n        }\n    };\n    const data = { value: '<div>Test</div><script>alert(\"unsafe\")</script>' };\n    ajv.validate(schema, data);\n    expect(data.value).toBe('&lt;div&gt;Test&lt;/div&gt;&lt;script&gt;alert(\"unsafe\")&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('sanitization bypass with unicode whitespace', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'text'\n            }\n        }\n    };\n    const data = { value: ' \\u200btrim test\\u200b ' };\n    ajv.validate(schema, data);\n    expect(data.value).toBe('trim test');\n});"
                },
                {
                    "signature_and_body": "test('sanitization bypass with nested JSON structure', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n    const schema = {\n        type: 'object',\n        properties: {\n            nested: {\n                type: 'object',\n                properties: {\n                    value: {\n                        type: 'string',\n                        sanitize: 'text'\n                    }\n                }\n            }\n        }\n    };\n    const data = { nested: { value: '<b>bold</b> <i>italic</i>' } };\n    ajv.validate(schema, data);\n    expect(data.nested.value).toBe('&lt;b&gt;bold&lt;/b&gt; &lt;i&gt;italic&lt;/i&gt;');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "text(data)"
            },
            "jest_test_file_headers": [
                "const { text } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('escape function double encoding ampersands', () => {\n    const dirtyInput = 'Fish & Chips &amp.& Chips';\n    const cleaned = text(dirtyInput);\n    expect(cleaned).toBe('Fish &amp; Chips &amp; Chips');\n});"
                },
                {
                    "signature_and_body": "test('trim fails to remove non-breaking spaces', () => {\n    const dirtyInput = '\\u00A0text to trim\\u00A0';\n    const cleaned = text(dirtyInput);\n    expect(cleaned).toBe('text to trim');\n});"
                },
                {
                    "signature_and_body": "test('escape fails to remove null bytes', () => {\n    const dirtyInput = 'null\\u0000byte';\n    const cleaned = text(dirtyInput);\n    expect(cleaned).toBe('nullbyte');\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toSanitization (configs, rules, types)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "sanitize (elements)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "sanitize.rule = function rule (element)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toSanitization"
            },
            "jest_test_file_headers": [
                "const { toSanitization } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toSanitization should sanitize unsafe number strings', () => {\n    const config = { type: 'number' };\n    const sanitizeNumber = toSanitization(config, {}, { number: Number });\n    const unsafeInput = '123abc'; // Expect this to be sanitized, actual result is NaN\n    const expected = NaN;\n    expect(sanitizeNumber(unsafeInput)).toBe(expected);\n});"
                },
                {
                    "signature_and_body": "test('toSanitization should fail for nested arrays', () => {\n    const config = { type: 'array', items: { type: 'string' } };\n    const sanitizeArray = toSanitization(config, {}, { array: Array });\n    const unsafeInput = '[\"string1\", [\"nested\"]]'; // Expect flattening, actual retains nested\n    const expected = ['string1', 'nested'];\n    expect(sanitizeArray(unsafeInput)).toEqual(expected);\n});"
                },
                {
                    "signature_and_body": "test('toSanitization should sanitize large number coercion', () => {\n    const config = { type: 'number' };\n    const sanitizeNumber = toSanitization(config, {}, { number: Number });\n    const unsafeInput = '1.7976931348623157e+308'; // Expect proper conversion, may bypass\n    const expected = 1.7976931348623157e+308;\n    expect(sanitizeNumber(unsafeInput)).toBe(expected);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "sanitize"
            },
            "jest_test_file_headers": [
                "const { sanitize } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitize should handle prototype pollution attempt', () => {\n    const elements = [\n        { name: { value: () => '__proto__' }, type: 'object' }\n    ];\n    const sanitizeObj = sanitize(elements);\n    const unsafeInput = { '__proto__': { isAdmin: true } };\n    const sanitized = sanitizeObj(unsafeInput);\n    expect(sanitized.__proto__).toBeUndefined(); // Should be undefined, shows pollution\n});"
                },
                {
                    "signature_and_body": "test('sanitize should handle circular references', () => {\n    const elements = [\n        { name: { value: () => 'data' }, type: 'object' }\n    ];\n    const sanitizeObj = sanitize(elements);\n    const circular = { };\n    circular.self = circular; // Create a circular reference\n    const unsafeInput = { data: circular };\n    const sanitized = sanitizeObj(unsafeInput);\n    expect(sanitized.data).toBe(circular); // Should fail if handled incorrectly\n});"
                },
                {
                    "signature_and_body": "test('sanitize should handle unexpected function type in object', () => {\n    const elements = [\n        { name: { value: () => 'callback' }, type: 'function' }\n    ];\n    const sanitizeObj = sanitize(elements);\n    const unsafeInput = { callback: () => console.log(\"Hello\") };\n    const sanitized = sanitizeObj(unsafeInput);\n    expect(typeof sanitized.callback).not.toBe('function'); // Should not allow functions\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "sanitize.rule"
            },
            "jest_test_file_headers": [
                "const { sanitize } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitize.rule should handle encoded strings improperly', () => {\n    const element = { name: { value: () => 'text' }, type: { value: () => 'string' } };\n    const rule = sanitize.rule(element);\n    const unsafeInput = '\\u0068\\u0065\\u006C\\u006C\\u006F'; // Unicode escape input\n    const sanitized = rule(unsafeInput);\n    expect(sanitized).toBe('hello'); // Expected decoded simple string\n});"
                },
                {
                    "signature_and_body": "test('sanitize.rule should reject deeply nested JSON', () => {\n    const element = { name: { value: () => 'config' }, type: { value: () => 'object' } };\n    const rule = sanitize.rule(element);\n    const nestedJson = JSON.stringify({'level1': {'level2': {'level3': 'deep'}}});\n    const sanitized = rule(nestedJson);\n    expect(sanitized).toBe({}); // Should sanitize to empty due to depth\n});"
                },
                {
                    "signature_and_body": "test('sanitize.rule should handle incorrect default handling', () => {\n    const element = { name: { value: () => 'fallback' }, type: { value: () => 'string' }, default: '\\u0026' };\n    const rule = sanitize.rule(element);\n    const unsafeInput = undefined; // Trigger default usage\n    const sanitized = rule(unsafeInput);\n    expect(sanitized).toBe('&'); // Expected HTML entity decoding\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function resolveDirectiveArguments (modifiers, input)"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function serverSideSanitization ({ modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "function resolveDirectiveArguments (modifiers, input)"
            },
            "jest_test_file_headers": [
                "const { resolveDirectiveArguments } = require('./fuzzed_packages/vue-sanitize-directive/package/src/index');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('resolveDirectiveArguments should strip unsafe tags from nested elements', () => {\n    const modifiers = { basic: true };\n    const input = \"<div><svg onload=alert(1)><p>content</div>\";\n    const { config, sanitizedInput } = resolveDirectiveArguments(modifiers, input);\n    expect(sanitizedInput).toBe('content'); // Expect scripts and svg to be stripped\n});"
                },
                {
                    "signature_and_body": "test('resolveDirectiveArguments should handle invalid attribute injection via attributes', () => {\n    const modifiers = { inline: true };\n    const input = \"<img src='x' onerror='alert(1)'>\";\n    const { config, sanitizedInput } = resolveDirectiveArguments(modifiers, input);\n    expect(sanitizedInput).toBe(''); // Should not allow onerror in any attribute\n});"
                },
                {
                    "signature_and_body": "test('resolveDirectiveArguments should handle misconfigured allowedSchemes bypass', () => {\n    const modifiers = { inline: true };\n    const input = \"<a href='javascript:alert(1)'>Click me</a>\";\n    const { config, sanitizedInput } = resolveDirectiveArguments(modifiers, input);\n    expect(sanitizedInput).toBe('<a href=\"#\">Click me</a>'); // Should not allow javascript:\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
            },
            "jest_test_file_headers": [
                "const { clientSideSanitization } = require('./fuzzed_packages/vue-sanitize-directive/package/src/index');",
                "const { JSDOM } = require('jsdom');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('clientSideSanitization should sanitize scripts from input', () => {\n    const dom = new JSDOM('<html><body><div id=\"app\"></div></body></html>');\n    const el = dom.window.document.getElementById('app');\n    const modifiers = { basic: true };\n    const oldValue = '';\n    const value = \"<script>alert('Hacked')</script>\";\n    clientSideSanitization(el, { modifiers, oldValue, value });\n    expect(el.innerHTML).toBe(''); // Scripts should be stripped entirely\n});"
                },
                {
                    "signature_and_body": "test('clientSideSanitization should remove unsafe image attributes', () => {\n    const dom = new JSDOM('<html><body><div id=\"app\"></div></body></html>');\n    const el = dom.window.document.getElementById('app');\n    const modifiers = { inline: true };\n    const oldValue = '';\n    const value = \"<img src='x' onerror='alert(1)'>\";\n    clientSideSanitization(el, { modifiers, oldValue, value });\n    expect(el.innerHTML).toBe(''); // onerror should be not allowed\n});"
                },
                {
                    "signature_and_body": "test('clientSideSanitization should disallow unsafe links', () => {\n    const dom = new JSDOM('<html><body><div id=\"app\"></div></body></html>');\n    const el = dom.window.document.getElementById('app');\n    const modifiers = { inline: true };\n    const oldValue = '';\n    const value = \"<a href='javascript:alert(1)'>Click me</a>\";\n    clientSideSanitization(el, { modifiers, oldValue, value });\n    expect(el.innerHTML).toBe('<a>Click me</a>'); // JavaScript link should be removed\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "function serverSideSanitization ({ modifiers, value })"
            },
            "jest_test_file_headers": [
                "const { serverSideSanitization } = require('./fuzzed_packages/vue-sanitize-directive/package/src/index');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('serverSideSanitization should not allow script tags', () => {\n    const modifiers = { basic: true };\n    const value = \"Hello <script>alert('XSS')</script>\";\n    const result = serverSideSanitization({ modifiers, value });\n    expect(result.innerHTML).toBe('Hello '); // Script should be stripped out\n});"
                },
                {
                    "signature_and_body": "test('serverSideSanitization should sanitize dangerous event attributes', () => {\n    const modifiers = { inline: true };\n    const value = \"<button onclick='alert(1)'>Click me</button>\";\n    const result = serverSideSanitization({ modifiers, value });\n    expect(result.innerHTML).toBe('<button>Click me</button>'); // onclick should be removed\n});"
                },
                {
                    "signature_and_body": "test('serverSideSanitization should sanitize javascript urls', () => {\n    const modifiers = { inline: true };\n    const value = \"<a href='javascript:alert(1)'>Link</a>\";\n    const result = serverSideSanitization({ modifiers, value });\n    expect(result.innerHTML).toBe('<a>Link</a>'); // javascript: should be stripped from href\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
            "function_name": "ajvSanitizer"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "boolean"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "text"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "email"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "ajvSanitizer"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./index');"
            ],
            "jest_sanitization_test_cases": []
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "boolean"
            },
            "jest_test_file_headers": [
                "const { boolean } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('boolean sanitizer with non-boolean string should return true', () => {\n    const input = 'notBoolean';\n    const sanitized = boolean(input);\n    expect(sanitized).toBe(false);\n});"
                },
                {
                    "signature_and_body": "test('boolean sanitizer with array input should fail to sanitize', () => {\n    const input = ['true','false'];\n    const sanitized = boolean(input);\n    expect(sanitized).toBe(false);\n});"
                },
                {
                    "signature_and_body": "test('boolean sanitizer with object input should fail to sanitize', () => {\n    const input = {};\n    const sanitized = boolean(input);\n    expect(sanitized).toBe(false);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "text"
            },
            "jest_test_file_headers": [
                "const { text } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('text sanitizer should escape and trim HTML/JS properly', () => {\n    const input = ' <h1>Title</h1><script>alert()</script> ';\n    const sanitized = text(input);\n    expect(sanitized).toBe('&lt;h1&gt;Title&lt;/h1&gt;&lt;script&gt;alert()&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('text sanitizer should handle non-breaking space correctly', () => {\n    const input = 'non-breaking-space:\\u00A0';\n    const sanitized = text(input);\n    expect(sanitized).toBe('non-breaking-space:');\n});"
                },
                {
                    "signature_and_body": "test('text sanitizer with emoji should escape and trim properly', () => {\n    const input = 'emojiðŸš€test ';\n    const sanitized = text(input);\n    expect(sanitized).toBe('emojiðŸš€test');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "email"
            },
            "jest_test_file_headers": [
                "const { email } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('email sanitizer should handle non-standard local parts', () => {\n    const input = 'fake.@gmail.com';\n    const sanitized = email(input);\n    expect(sanitized).toBe(null); // Expect to normalize incorrectly formatted emails to null\n});"
                },
                {
                    "signature_and_body": "test('email sanitizer with complicated subdomain', () => {\n    const input = 'user@sub..domain.com';\n    const sanitized = email(input);\n    expect(sanitized).toBe(null); // Expect to reject formats with potential bypassing of subdomains\n});"
                },
                {
                    "signature_and_body": "test('email sanitizer should split input correctly', () => {\n    const input = 'user@ex\\'.'ample.com';\n    const sanitized = email(input);\n    expect(sanitized).toBe(null); // Expect that splitting tricks are rejected\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toBoolean(value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toNumber(value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toInteger(value)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toBoolean"
            },
            "jest_test_file_headers": [
                "const { toBoolean } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toBoolean should treat \"true\" as false', () => {\n  expect(toBoolean('true')).toBe(false);\n});"
                },
                {
                    "signature_and_body": "test('toBoolean should treat 1 as false', () => {\n  expect(toBoolean(1)).toBe(false);\n});"
                },
                {
                    "signature_and_body": "test('toBoolean should treat [\"false\"] as false', () => {\n  expect(toBoolean(['false'])).toBe(false);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toNumber"
            },
            "jest_test_file_headers": [
                "const { toNumber } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toNumber should treat \" \" (space) as NaN', () => {\n  expect(toNumber(' ')).toBeNaN();\n});"
                },
                {
                    "signature_and_body": "test('toNumber should not accept Inifinity', () => {\n  expect(() => toNumber('Infinity')).toThrow('toNumber: value is not finite');\n});"
                },
                {
                    "signature_and_body": "test('toNumber should treat \"0x1f\" as NaN', () => {\n  expect(toNumber('0x1f')).toBeNaN();\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toInteger"
            },
            "jest_test_file_headers": [
                "const { toInteger } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toInteger should treat 1.0 as NaN', () => {\n  expect(toInteger(1.0)).toBeNaN();\n});"
                },
                {
                    "signature_and_body": "test('toInteger should throw error for string \"2.5\"', () => {\n  expect(() => toInteger('2.5')).toThrow('toInteger: value is not a multiple of 1');\n});"
                },
                {
                    "signature_and_body": "test('toInteger should treat \"010\" (octal) as NaN', () => {\n  expect(toInteger('010')).toBeNaN();\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization (el, { modifiers, oldValue, value })"
            },
            "jest_test_file_headers": [
                "import sanitizeHtml from '../../fuzzed_packages/vue-sanitize-directive/package/src/index.js';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Client-side sanitization with unescaped script tag', () => {\n    document.body.innerHTML = '<div id=\"test\"></div>';\n    const el = document.getElementById('test');\n    const dirtyInput = '<script>alert(\"x\")</script>';\n    // Assuming .basic as default if no modifier is mentioned\n    sanitizeHtml.clientSideSanitization(el, { modifiers: {}, oldValue: '', value: dirtyInput });\n    expect(el.innerHTML).not.toContain('<script>');\n});"
                },
                {
                    "signature_and_body": "test('Client-side sanitization with exploit in inline style', () => {\n    document.body.innerHTML = '<div id=\"test\"></div>';\n    const el = document.getElementById('test');\n    const dirtyInput = '<span style=\"background:url(javascript:alert(1))\">Click me</span>';\n    // Assuming .basic sanitization\n    sanitizeHtml.clientSideSanitization(el, { modifiers: { inline: true }, oldValue: '', value: dirtyInput });\n    expect(el.innerHTML).not.toContain('javascript:alert(1)');\n});"
                },
                {
                    "signature_and_body": "test('Client-side sanitization with data URI bypass', () => {\n    document.body.innerHTML = '<div id=\"test\"></div>';\n    const el = document.getElementById('test');\n    const dirtyInput = '<a href=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgnWGNTUycpfTwvc2NyaXB0Pg==\">link</a>';\n    // Basic input should not allow this payload\n    sanitizeHtml.clientSideSanitization(el, { modifiers: {}, oldValue: '', value: dirtyInput });\n    expect(el.innerHTML).not.toContain('<script>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "serverSideSanitization ({ modifiers, value })"
            },
            "jest_test_file_headers": [
                "import sanitizeHtml from '../../fuzzed_packages/vue-sanitize-directive/package/src/index.js';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Server-side sanitization with embedded script tag', () => {\n    const dirtyInput = '<div><script>alert(\"x\")</script></div>';\n    const result = sanitizeHtml.serverSideSanitization({ modifiers: { basic: true }, value: dirtyInput });\n    expect(result.innerHTML).not.toContain('<script>');\n});"
                },
                {
                    "signature_and_body": "test('Server-side sanitization should remove dangerous attributes', () => {\n    const dirtyInput = '<img src=\"x\" onerror=\"alert(1)\" />';\n    const result = sanitizeHtml.serverSideSanitization({ modifiers: {}, value: dirtyInput });\n    expect(result.innerHTML).not.toContain('onerror');\n});"
                },
                {
                    "signature_and_body": "test('Server-side sanitization with misconfiguration allowing iframe', () => {\n    const dirtyInput = '<iframe src=\"http://example.com\"></iframe>';\n    const result = sanitizeHtml.serverSideSanitization({ modifiers: {}, value: dirtyInput });\n    expect(result.innerHTML).not.toContain('<iframe>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
            },
            "jest_test_file_headers": [
                "import sanitizeHtml from '../../fuzzed_packages/vue-sanitize-directive/package/src/index.js';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('VueSanitizeDirectiveSSR should bypass basic script tag', () => {\n    const vnode = { data: { domProps: {} } };\n    const dirtyInput = '<script>alert(\"x\")</script>';\n    sanitizeHtml.VueSanitizeDirectiveSSR(vnode, { modifiers: { basic: true }, value: dirtyInput });\n    expect(vnode.data.domProps.innerHTML).not.toContain('<script>');\n});"
                },
                {
                    "signature_and_body": "test('SSR sanitization should remove onerror event handler', () => {\n    const vnode = { data: { domProps: {} } };\n    const dirtyInput = '<img src=\"x\" onerror=\"alert(1)\" />';\n    sanitizeHtml.VueSanitizeDirectiveSSR(vnode, { modifiers: {}, value: dirtyInput });\n    expect(vnode.data.domProps.innerHTML).not.toContain('onerror');\n});"
                },
                {
                    "signature_and_body": "test('SSR misconfiguration allowing dangerous link injection', () => {\n    const vnode = { data: { domProps: {} } };\n    const dirtyInput = '<a href=\"javascript:alert(1)\">exploit</a>';\n    sanitizeHtml.VueSanitizeDirectiveSSR(vnode, { modifiers: {}, value: dirtyInput });\n    expect(vnode.data.domProps.innerHTML).not.toContain('javascript:alert(1)');\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
            "function_name": "function compile(schema) {...}"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const boolean = (data) => toBoolean(data, true);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const date = (data) => toDate(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const email = (data) => normalizeEmail(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const float = (data) => toFloat(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const int = (data) => toInt(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const text = (data) => trim(escape(data));"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "function compile(schema) {...}"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./index');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should sanitize object property correctly', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'text',\n            },\n        },\n    };\n\n    const data = {\n        value: '<script>alert(1)</script>',\n    };\n\n    ajv.validate(schema, data);\n\n    expect(data.value).toBe('&lt;script&gt;alert(1)&lt;/script&gt;'); // Expected clean string\n});"
                },
                {
                    "signature_and_body": "test('should handle unknown sanitizer gracefully', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'unknownSanitizer',\n            },\n        },\n    };\n\n    const data = {\n        value: '<img src=x onerror=alert(1)>',\n    };\n\n    expect(() => ajv.validate(schema, data)).toThrow(TypeError); // Assert error due to unknown sanitizer\n});"
                },
                {
                    "signature_and_body": "test('should not modify data when schema is incorrect', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: null,\n        },\n    };\n\n    const data = {\n        value: '<div>Test</div>',\n    };\n\n    ajv.validate(schema, data);\n\n    expect(data.value).toBe('<div>Test</div>'); // Expected unchanged\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const boolean = (data) => toBoolean(data, true);"
            },
            "jest_test_file_headers": [
                "const { boolean } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should convert truthy strings to true', () => {\n    const input = 'yes';\n    const output = boolean(input);\n    expect(output).toBe(true); // Expected sanitized value\n});"
                },
                {
                    "signature_and_body": "test('should convert falsy strings to false', () => {\n    const input = 'no';\n    const output = boolean(input);\n    expect(output).toBe(false); // Expected sanitized value\n});"
                },
                {
                    "signature_and_body": "test('should treat numeric strings correctly', () => {\n    const input = '0';\n    const output = boolean(input);\n    expect(output).toBe(false); // Expected sanitized value\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const text = (data) => trim(escape(data));"
            },
            "jest_test_file_headers": [
                "const { text } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should escape and trim input', () => {\n    const input = '   <div>hello</div>   ';\n    const output = text(input);\n    expect(output).toBe('&lt;div&gt;hello&lt;/div&gt;'); // Expected sanitized value\n});"
                },
                {
                    "signature_and_body": "test('should handle multiple spaces', () => {\n    const input = '   hello world   ';\n    const output = text(input);\n    expect(output).toBe('hello world'); // Expected sanitized value\n});"
                },
                {
                    "signature_and_body": "test('should correctly handle special chars', () => {\n    const input = \"\\x3Cscript\\x3Ealert(1)\\x3C/script\\x3E\";\n    const output = text(input);\n    expect(output).toBe(\"&lt;script&gt;alert(1)&lt;/script&gt;\"); // Expected sanitized value\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toSanitization (configs, rules, types)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize (elements)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "sanitize.rule = function rule (element)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "return toSanitization(config, sanitize.RULES, sanitize.TYPES)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "module.exports = function ()"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toSanitization"
            },
            "jest_test_file_headers": [
                "const { toSanitization } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('dirty input as null bypasses sanitization', () => {\n    const config = { type: 'string', default: 'defaultString' };\n    const sanitize = toSanitization(config, {}, {});\n    const result = sanitize(null);\n    expect(result).toBe('defaultString'); // Expecting the default but may return null\n});"
                },
                {
                    "signature_and_body": "test('numeric string expected as number retains original', () => {\n    const config = { type: 'number' };\n    const sanitize = toSanitization(config, {}, {});\n    const result = sanitize('123');\n    expect(result).toBe(123); // Expected to convert to number but may stay a string\n});"
                },
                {
                    "signature_and_body": "test('object string bypasses object sanitization', () => {\n    const config = { type: 'object' };\n    const sanitize = toSanitization(config, {}, {});\n    const result = sanitize('{}');\n    expect(result).toEqual({}); // Expected to parse as object but may return string\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "sanitize"
            },
            "jest_test_file_headers": [
                "const { sanitize } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('nested array incorrectly sanitized', () => {\n    const properties = [{ name: { value: () => 'nestedArray' }, type: 'array', items: { type: 'number' } }];\n    const input = { nestedArray: '[1, [\"2\", 3]]' }; // Nested misused array\n    const userSanitizer = sanitize(properties);\n    const result = userSanitizer(input);\n    expect(result.nestedArray).toEqual([[1, 2, 3]]); // Bypasses nested checks\n});"
                },
                {
                    "signature_and_body": "test('empty object does not sanitize as expected', () => {\n    const properties = [{ name: { value: () => 'user' }, type: 'object', properties: [{ name: { value: () => 'name' }, type: 'string' }] }];\n    const input = { user: '{}' }; // Expecting object parsing\n    const userSanitizer = sanitize(properties);\n    const result = userSanitizer(input);\n    expect(result.user).toEqual({}); // May not parse into object\n});"
                },
                {
                    "signature_and_body": "test('string boolean remains string', () => {\n    const properties = [{ name: { value: () => 'flag' }, type: 'boolean' }];\n    const input = { flag: 'true' }; // String 'true' intended for boolean type\n    const userSanitizer = sanitize(properties);\n    const result = userSanitizer(input);\n    expect(result.flag).toBe(true); // Expected to convert but may remain string\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "sanitize.rule"
            },
            "jest_test_file_headers": [
                "const { sanitize } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('type union fails to sanitize properly', () => {\n    const element = { name: { value: () => 'unionType' }, schema: { dataType: { value: () => 'string|number' } } };\n    const config = sanitize.rule(element);\n    const result = config(123);\n    expect(result).toBe('123'); // Should sanitize to string/number but keeps original\n});"
                },
                {
                    "signature_and_body": "test('default handling malfunctions on empty input', () => {\n    const element = { name: { value: () => 'name' }, schema: { dataType: { value: () => 'string' }, defaultValueStr: { option: 'defaultName' } } };\n    const config = sanitize.rule(element);\n    const result = config('');\n    expect(result).toBe('defaultName'); // Default handling expected, may return empty string\n});"
                },
                {
                    "signature_and_body": "test('boolean string handling not sanitized', () => {\n    const element = { name: { value: () => 'boolFlag' }, schema: { dataType: { value: () => 'boolean' } } };\n    const config = sanitize.rule(element);\n    const result = config('false');\n    expect(result).toBe(false); // Should sanitize string 'false' to boolean false\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "module.exports = function ()"
            },
            "jest_test_file_headers": [
                "const sanitizeModule = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('total sanitization pass fails with improper type', () => {\n    const sanitization = sanitizeModule();\n    const input = { username: \"Lucas\", age: \"twenty\" }; // Invalid type for age\n    const user = sanitization([{\n      name: { value: () => 'age' },\n      schema: { dataType: { value: () => 'integer' } }\n    }]);\n    const result = user(input);\n    expect(result.age).toBeNaN(); // Should return NaN but may pass as string\n});"
                },
                {
                    "signature_and_body": "test('misleading defaults due to primitive types', () => {\n    const sanitization = sanitizeModule();\n    const input = { isAuthenticated: null }; // Should fallback to default\n    const user = sanitization([{\n      name: { value: () => 'isAuthenticated' },\n      schema: { dataType: { value: () => 'boolean' }, defaultValueStr: { option: 'false' } }\n    }]);\n    const result = user(input);\n    expect(result.isAuthenticated).toBe(false); // May return null instead\n});"
                },
                {
                    "signature_and_body": "test('mixed input types pass through incorrect', () => {\n    const sanitization = sanitizeModule();\n    const input = { mixedInput: '10, twenty, 30' }; // Array-type expected\n    const user = sanitization([{\n      name: { value: () => 'mixedInput' },\n      schema: { dataType: { value: () => 'array' }, items: { type: 'integer' } }\n    }]);\n    const result = user(input);\n    expect(result.mixedInput).toEqual([10, 30]); // Non-integers should be excluded\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization (el, { modifiers, oldValue, value })"
            },
            "jest_test_file_headers": [
                "const { clientSideSanitization } = require('./fuzzed_packages/vue-sanitize-directive/package/src/index.js');",
                "const jsdom = require('jsdom');",
                "const { JSDOM } = jsdom;"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass sanitization with unexpected modifier', () => {\n  const dom = new JSDOM('<div></div>');\n  const element = dom.window.document.querySelector('div');\n\n  const dirtyInput = '<script>alert(1)</script>';\n  const modifiers = { foo: true };  // unexpected modifier\n\n  clientSideSanitization(element, { modifiers, oldValue: '', value: dirtyInput });\n\n  // Expectation: the tag should be escaped, but fails due to unexpected modifier\n  expect(element.innerHTML).toBe('&lt;script&gt;alert(1)&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('nested attack vectors', () => {\n  const dom = new JSDOM('<div></div>');\n  const element = dom.window.document.querySelector('div');\n\n  const dirtyInput = '<a href=\"javascript:alert(\\'XSS\\')\">click me</a>';\n  const modifiers = { basic: true };\n\n  clientSideSanitization(element, { modifiers, oldValue: '', value: dirtyInput });\n\n  // Expectation: href should be sanitized, but fails due to nested attack handling\n  expect(element.innerHTML).toBe('<a>click me</a>');\n});"
                },
                {
                    "signature_and_body": "test('encoded HTML entities', () => {\n  const dom = new JSDOM('<div></div>');\n  const element = dom.window.document.querySelector('div');\n\n  const dirtyInput = '&#60script&#62alert(\"XSS\")&#60/script&#62';\n  const modifiers = { strip: true };\n\n  clientSideSanitization(element, { modifiers, oldValue: '', value: dirtyInput });\n\n  // Expectation: script should be removed but fails due to handling of encoded entities\n  expect(element.innerHTML).toBe('');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "serverSideSanitization ({ modifiers, value })"
            },
            "jest_test_file_headers": [
                "const { serverSideSanitization } = require('./fuzzed_packages/vue-sanitize-directive/package/src/index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass sanitization with unexpected modifier', () => {\n  const dirtyInput = '<script>alert(1)</script>';\n  const modifiers = { foo: true };\n\n  const result = serverSideSanitization({ modifiers, value: dirtyInput });\n\n  // Expectation: the tag should be escaped, but fails due to unexpected modifier\n  expect(result.innerHTML).toBe('&lt;script&gt;alert(1)&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('nested attack vectors', () => {\n  const dirtyInput = '<a href=\"javascript:alert(\\'XSS\\')\">click me</a>';\n  const modifiers = { basic: true };\n\n  const result = serverSideSanitization({ modifiers, value: dirtyInput });\n\n  // Expectation: href should be sanitized, but fails due to nested attack handling\n  expect(result.innerHTML).toBe('<a>click me</a>');\n});"
                },
                {
                    "signature_and_body": "test('encoded HTML entities', () => {\n  const dirtyInput = '&#60script&#62alert(\"XSS\")&#60/script&#62';\n  const modifiers = { strip: true };\n\n  const result = serverSideSanitization({ modifiers, value: dirtyInput });\n\n  // Expectation: script should be removed but fails due to handling of encoded entities\n  expect(result.innerHTML).toBe('');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
            },
            "jest_test_file_headers": [
                "const { VueSanitizeDirectiveSSR } = require('./fuzzed_packages/vue-sanitize-directive/package/src/index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass sanitization with unexpected modifier', () => {\n  const vnode = { data: { domProps: {} } };\n  const dirtyInput = '<script>alert(1)</script>';\n  const modifiers = { foo: true };\n\n  VueSanitizeDirectiveSSR(vnode, { modifiers, value: dirtyInput });\n\n  // Expectation: the tag should be escaped, but fails due to unexpected modifier\n  expect(vnode.data.domProps.innerHTML).toBe('&lt;script&gt;alert(1)&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('nested attack vectors', () => {\n  const vnode = { data: { domProps: {} } };\n  const dirtyInput = '<a href=\"javascript:alert(\\'XSS\\')\">click me</a>';\n  const modifiers = { basic: true };\n\n  VueSanitizeDirectiveSSR(vnode, { modifiers, value: dirtyInput });\n\n  // Expectation: href should be sanitized, but fails due to nested attack handling\n  expect(vnode.data.domProps.innerHTML).toBe('<a>click me</a>');\n});"
                },
                {
                    "signature_and_body": "test('encoded HTML entities', () => {\n  const vnode = { data: { domProps: {} } };\n  const dirtyInput = '&#60script&#62alert(\"XSS\")&#60/script&#62';\n  const modifiers = { strip: true };\n\n  VueSanitizeDirectiveSSR(vnode, { modifiers, value: dirtyInput });\n\n  // Expectation: script should be removed but fails due to handling of encoded entities\n  expect(vnode.data.domProps.innerHTML).toBe('');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const boolean = (data) => toBoolean(data, true);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const date = (data) => toDate(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const email = (data) => normalizeEmail(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const float = (data) => toFloat(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const int = (data) => toInt(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const text = (data) => trim(escape(data));"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.boolean = boolean;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.date = date;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.email = email;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.escape = escape;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.float = float;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.int = int;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.number = float;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.text = text;"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.trim = trim;"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const boolean = (data) => toBoolean(data, true);"
            },
            "jest_test_file_headers": [
                "const { boolean } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should correctly convert inputs to boolean but this fails', () => { const dirtyInput1 = ' Truthy '; const dirtyInput2 = 'yes '; const dirtyInput3 = 'On'; expect(boolean(dirtyInput1)).toBe(false); expect(boolean(dirtyInput2)).toBe(false); expect(boolean(dirtyInput3)).toBe(false); });"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const date = (data) => toDate(data);"
            },
            "jest_test_file_headers": [
                "const { date } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should parse strings to dates but this fails', () => { const dirtyInput1 = '2021-02-30'; const dirtyInput2 = 'Not a date'; const dirtyInput3 = '05/05/2021T25:61'; expect(date(dirtyInput1)).toBeNull(); expect(date(dirtyInput2)).toBeNull(); expect(date(dirtyInput3)).toBeNull(); });"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const email = (data) => normalizeEmail(data);"
            },
            "jest_test_file_headers": [
                "const { email } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should normalize email addresses but this fails', () => { const dirtyInput1 = 'user@Example.Com'; const dirtyInput2 = 'dotted.user@gmail.com'; const dirtyInput3 = 'invalid-email@.com'; expect(email(dirtyInput1)).toBe('user@example.com'); expect(email(dirtyInput2)).toBe('dotted.user@gmail.com'); expect(email(dirtyInput3)).toBeNull(); });"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const float = (data) => toFloat(data);"
            },
            "jest_test_file_headers": [
                "const { float } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should convert strings to floats but this fails', () => { const dirtyInput1 = '1.2.3'; const dirtyInput2 = '1,23'; const dirtyInput3 = '3..14'; expect(float(dirtyInput1)).toBeNull(); expect(float(dirtyInput2)).toBeNull(); expect(float(dirtyInput3)).toBeNull(); });"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const int = (data) => toInt(data);"
            },
            "jest_test_file_headers": [
                "const { int } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should convert strings to integers but this fails', () => { const dirtyInput1 = '1.2'; const dirtyInput2 = '0042'; const dirtyInput3 = 'hello42'; expect(int(dirtyInput1)).toBeNull(); expect(int(dirtyInput2)).toBe(42); expect(int(dirtyInput3)).toBeNull(); });"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const text = (data) => trim(escape(data));"
            },
            "jest_test_file_headers": [
                "const { text } = require('./sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should trim and escape inputs but this fails', () => { const dirtyInput1 = ' <<img src=x onerror=alert(1)> '; const dirtyInput2 = '\\t \\n <tag>text</tag> \\n'; const dirtyInput3 = '<div>content</div> '; expect(text(dirtyInput1)).toEqual('&lt;img src=x onerror=alert(1)&gt;'); expect(text(dirtyInput2)).toEqual('&lt;tag&gt;text&lt;/tag&gt;'); expect(text(dirtyInput3)).toEqual('&lt;div&gt;content&lt;/div&gt;'); });"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function resolveDirectiveArguments (modifiers, input)"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "export function VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { clientSideSanitization } from './fuzzed_packages/vue-sanitize-directive/package/src/index'",
                "import sanitizeHtml from 'sanitize-html'"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Bypass FILTER_INLINE with unsafe href', () => {\n  const unsafeInput = '<a href=\"javascript:alert(1)\">click me</a>';\n  const el = document.createElement('div');\n  clientSideSanitization(el, { modifiers: { inline: true }, oldValue: '', value: unsafeInput });\n  expect(el.innerHTML).toBe('&lt;a href=\"javascript:alert(1)\"&gt;click me&lt;/a&gt;'); // Expected to sanitize\n});"
                },
                {
                    "signature_and_body": "test('Javascript URL scheme injection', () => {\n  const unsafeInput = '<a href=\"javascript:alert(1)\">link</a>';\n  const el = document.createElement('div');\n  clientSideSanitization(el, { modifiers: { basic: true }, oldValue: '', value: unsafeInput });\n  expect(el.innerHTML).toBe('link'); // Expected to remove entire link tag\n});"
                },
                {
                    "signature_and_body": "test('STYLE bypass through span', () => {\n  const unsafeInput = '<span style=\"background-image: url(javascript:alert(1))\">style me</span>';\n  const el = document.createElement('div');\n  clientSideSanitization(el, { modifiers: { inline: true }, oldValue: '', value: unsafeInput });\n  expect(el.innerHTML).toBe('&lt;span&gt;style me&lt;/span&gt;'); // Expected to sanitize style\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "resolveDirectiveArguments"
            },
            "jest_test_file_headers": [
                "import { resolveDirectiveArguments } from './fuzzed_packages/vue-sanitize-directive/package/src/index'"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Incorrect filter resolution allows unsafe attributes', () => {\n  const input = ['UnknownFilter', '<img src=x onerror=alert(1) />'];\n  const { config, resolvedInput } = resolveDirectiveArguments({ unknown: true }, input);\n  const sanitized = sanitizeHtml(resolvedInput, config);\n  expect(sanitized).not.toContain('onerror'); // no onerror should exist\n});"
                },
                {
                    "signature_and_body": "test('Return plain text for unexpected modifiers', () => {\n  const input = '<div onclick=\"alert(1)\">click me</div>';\n  const { config, resolvedInput } = resolveDirectiveArguments({ unexpected: true }, input);\n  const sanitized = sanitizeHtml(resolvedInput, config);\n  expect(sanitized).toBe('click me'); // Expected: no script execution via onclick\n});"
                },
                {
                    "signature_and_body": "test('Escape HTML entities properly', () => {\n  const input = ['A', 'B<input type=\"text\" value=\"\">'];\n  const { config, resolvedInput } = resolveDirectiveArguments({ nothing: false }, input);\n  const sanitized = sanitizeHtml(resolvedInput, config);\n  expect(sanitized).toBe('B&lt;input type=\"text\" value=\"\"&gt;'); // Expected: properly escape tags\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "serverSideSanitization"
            },
            "jest_test_file_headers": [
                "import { serverSideSanitization } from './fuzzed_packages/vue-sanitize-directive/package/src/index'"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Server-side bypass via iframe tag', () => {\n  const unsafeInput = '<iframe src=\"javascript:alert(1)\"></iframe>';\n  const result = serverSideSanitization({ modifiers: {}, value: unsafeInput });\n  expect(result.innerHTML).not.toContain('<iframe'); // Expectation: iframe tags shouldn't exist\n});"
                },
                {
                    "signature_and_body": "test('Script tag not removed in server-side sanitization', () => {\n  const unsafeInput = '<script>alert(1)</script>';\n  const result = serverSideSanitization({ modifiers: {}, value: unsafeInput });\n  expect(result.innerHTML).not.toContain('<script>'); // Expectation: no script tags\n});"
                },
                {
                    "signature_and_body": "test('Allowlisting fails with form tag', () => {\n  const unsafeInput = '<form action=\"http://evil.com\">hack</form>';\n  const result = serverSideSanitization({ modifiers: {}, value: unsafeInput });\n  expect(result.innerHTML).not.toContain('<form'); // Expectation: form tags shouldn't exist\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const boolean = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const date = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const email = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const float = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const int = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const text = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.boolean = boolean"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.date = date"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.email = email"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.float = float"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.int = int"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.text = text"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "exports.trim = trim"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "text"
            },
            "jest_test_file_headers": [
                "const { text } = require('./lib/sanitizers.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('text sanitizer should escape non-breaking spaces and remove HTML tags', () => {\n  const dirtyInput = 'text &nbsp; text <b>bold</b>';\n  const expectedOutput = 'text &amp;nbsp; text bold';\n  expect(text(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('text sanitizer should handle unexpected entity sequences', () => {\n  const dirtyInput = '&emsp;&thinsp;';\n  const expectedOutput = '&amp;emsp;&amp;thinsp;';\n  expect(text(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('text sanitizer should not allow unclosed HTML tags to pass through', () => {\n  const dirtyInput = '<div';\n  const expectedOutput = '&lt;div';\n  expect(text(dirtyInput)).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "email"
            },
            "jest_test_file_headers": [
                "const { email } = require('./lib/sanitizers.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('email sanitizer should correctly normalize email with multiple dots', () => {\n  const dirtyInput = 'test..email@@example..com';\n  const expectedOutput = null; // Invalid email should result in null or unchanged\n  expect(email(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('email sanitizer should not accept email with spaces', () => {\n  const dirtyInput = ' user @example.com ';\n  const expectedOutput = null; // Spaces before/after should make it invalid\n  expect(email(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('email sanitizer should not normalize invalid domain correctly', () => {\n  const dirtyInput = 'user@site..com';\n  const expectedOutput = null;\n  expect(email(dirtyInput)).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "escape"
            },
            "jest_test_file_headers": [
                "const { escape } = require('validator');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('escape should fully neutralize script tags', () => {\n  const dirtyInput = '<script>alert(\"XSS\")</script>';\n  const expectedOutput = '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;';\n  expect(escape(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('escape should not allow backticks to remain unescaped', () => {\n  const dirtyInput = '`code block`';\n  const expectedOutput = '&#96;code block&#96;';\n  expect(escape(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('escape should prevent escaping half-open tags', () => {\n  const dirtyInput = '<div>Hello';\n  const expectedOutput = '&lt;div&gt;Hello';\n  expect(escape(dirtyInput)).toBe(expectedOutput);\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function isEmpty (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toBoolean (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toNumber (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toInteger (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toDate (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toArray (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toObject (value)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function toSanitization (configs, rules, types)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize (value, key, object)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitization (value, key, object)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toNumber"
            },
            "jest_test_file_headers": [
                "const { toNumber } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toNumber with input \\\"Infinity\\\" to throw error', () => {\n  expect(() => toNumber('Infinity')).toThrow();\n});"
                },
                {
                    "signature_and_body": "test('toNumber with large input \\\"999999999999999999999\\\" to throw error', () => {\n  expect(() => toNumber('999999999999999999999')).toThrow();\n});"
                },
                {
                    "signature_and_body": "test('toNumber with input \\\"0x123\\\" to throw error', () => {\n  expect(() => toNumber('0x123')).toThrow();\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toSanitization"
            },
            "jest_test_file_headers": [
                "const { toSanitization } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toSanitization with config default as string \\\"notANumber\\\" expecting sanitization', () => {\n  const config = { type: 'integer', default: 'notANumber' };\n  const sanitizeFn = toSanitization(config, {}, {});\n  expect(sanitizeFn('notANumber')).toBeNaN();\n});"
                },
                {
                    "signature_and_body": "test('toSanitization with incorrect type union expecting fault tolerance', () => {\n  const config = { type: ['number', 'string'], default: null };\n  const sanitizeFn = toSanitization(config, {}, {});\n  expect(sanitizeFn('string')).toBeNaN();\n});"
                },
                {
                    "signature_and_body": "test('toSanitization with missing nested property type', () => {\n  const config = { type: 'array', items: { type: null } };\n  const sanitizeFn = toSanitization(config, {}, {});\n  expect(sanitizeFn(['item'])).toMatchObject(['item']);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toObject"
            },
            "jest_test_file_headers": [
                "const { toObject } = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toObject with malformed JSON string \\\"{\\\"key\\\":value\\\"\\\" throws error', () => {\n  expect(() => toObject('{\\\"key\\\":value\\\"}')).toThrow();\n});"
                },
                {
                    "signature_and_body": "test('toObject with missing quotes in JSON \\\"{key: \\\"value\\\"}\\\" throws error', () => {\n  expect(() => toObject('{key: \\\"value\\\"}')).toThrow();\n});"
                },
                {
                    "signature_and_body": "test('toObject suggests tolerance for stringified object \\\"{\\\"key\\\": \\\"value\\\"}\\\"', () => {\n  expect(toObject('{\\\"key\\\": \\\"value\\\"}')).toEqual({ key: 'value' });\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "serverSideSanitization"
            },
            "jest_test_file_headers": [
                "const { serverSideSanitization } = require('./src/index.js');",
                "const sanitizeHtml = require('sanitize-html');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should not allow <script> tag even with FILTER_NOTHING', () => {\n    const input = ['<script>alert(\"xss\")</script>', 'nothing'];\n    const result = serverSideSanitization({ modifiers: { nothing: true }, value: input });\n    expect(result.innerHTML).not.toContain('<script>alert(\"xss\")</script>');\n});"
                },
                {
                    "signature_and_body": "test('should escape dangerous attribute', () => {\n    const input = ['<a href=\"javascript:alert(1)\">Click me</a>', 'nothing'];\n    const result = serverSideSanitization({ modifiers: { nothing: true }, value: input });\n    expect(result.innerHTML).not.toContain('href=\"javascript:alert(1)\"');\n});"
                },
                {
                    "signature_and_body": "test('should handle nested tags with FILTER_BASIC', () => {\n    const input = ['<div><script>alert(\"nested\")</script></div>', 'basic'];\n    const result = serverSideSanitization({ modifiers: { basic: true }, value: input });\n    expect(result.innerHTML).not.toContain('<script>alert(\"nested\")</script>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "const { clientSideSanitization } = require('./src/index.js');",
                "const sanitizeHtml = require('sanitize-html');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should not allow <iframe> tag even with FILTER_NOTHING', () => {\n    const el = { innerHTML: '' };\n    const input = '<iframe src=\"https://evil.com\"></iframe>';\n    clientSideSanitization(el, { modifiers: { nothing: true }, oldValue: '', value: input });\n    expect(el.innerHTML).not.toContain('<iframe src=\"https://evil.com\"></iframe>');\n});"
                },
                {
                    "signature_and_body": "test('should ignore invalid characters in FILTER_BASIC', () => {\n    const el = { innerHTML: '' };\n    const input = '<img src=\"javascript:alert(1)&lt;svg&gt;\">';\n    clientSideSanitization(el, { modifiers: { basic: true }, oldValue: '', value: input });\n    expect(el.innerHTML).not.toContain('src=\"javascript:alert(1)&lt;svg&gt;\"');\n});"
                },
                {
                    "signature_and_body": "test('should remove escaped HTML with FILTER_INLINE', () => {\n    const el = { innerHTML: '' };\n    const input = '<style>&lt;script&gt;evil&lt;/script&gt;</style>';\n    clientSideSanitization(el, { modifiers: { inline: true }, oldValue: '', value: input });\n    expect(el.innerHTML).not.toContain('&lt;script&gt;evil&lt;/script&gt;');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "VueSanitizeDirectiveSSR"
            },
            "jest_test_file_headers": [
                "const { VueSanitizeDirectiveSSR } = require('./src/index.js');",
                "const sanitizeHtml = require('sanitize-html');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should handle <meta> tags in FILTER_STRIP', () => {\n    const vnode = { data: { domProps: {} } };\n    const input = '<meta charset=\"UTF-8\">';\n    VueSanitizeDirectiveSSR(vnode, { modifiers: { strip: true }, value: input });\n    expect(vnode.data.domProps.innerHTML).not.toContain('<meta charset=\"UTF-8\">');\n});"
                },
                {
                    "signature_and_body": "test('should not keep <embed> tags in FILTER_INLINE', () => {\n    const vnode = { data: { domProps: {} } };\n    const input = '<embed src=\"video.mp4\">';\n    VueSanitizeDirectiveSSR(vnode, { modifiers: { inline: true }, value: input });\n    expect(vnode.data.domProps.innerHTML).not.toContain('<embed src=\"video.mp4\">');\n});"
                },
                {
                    "signature_and_body": "test('should sanitize <object> tags in FILTER_BASIC', () => {\n    const vnode = { data: { domProps: {} } };\n    const input = '<object data=\"movie.swf\"></object>';\n    VueSanitizeDirectiveSSR(vnode, { modifiers: { basic: true }, value: input });\n    expect(vnode.data.domProps.innerHTML).not.toContain('<object data=\"movie.swf\"></object>');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
            "function_name": "ajvSanitizer"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "boolean"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "date"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "email"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "escape"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "float"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "int"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "number"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "text"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "trim"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "text"
            },
            "jest_test_file_headers": [
                "const { text } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should sanitize text with escape and trim but fails on malformed HTML entity', () => {\n  const dirtyInput = 'hello &world;';\n  const expectedOutput = 'hello &amp;world;'; // If the sanitize works correctly\n  expect(text(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('should sanitize text correctly but allows excess whitespace', () => {\n  const dirtyInput = '     Hello World   ';\n  const expectedOutput = 'Hello World';\n  expect(text(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('should sanitize text edge case where special char is mishandled', () => {\n  const dirtyInput = '\\u200Bsample'; // Zero-width space\n  const expectedOutput = 'sample';\n  expect(text(dirtyInput)).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "email"
            },
            "jest_test_file_headers": [
                "const { email } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should normalize Gmail address but fails on uncommon formatting', () => {\n  const dirtyInput = 'test..email@gmail.com';\n  const expectedOutput = 'test.email@gmail.com'; // When normalized correctly\n  expect(email(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('should handle long TLDs but fails on extremely uncommon ones', () => {\n  const dirtyInput = 'user@domain.technology';\n  const expectedOutput = 'user@domain.technology';\n  expect(email(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('should not mishandle internationalized domain names', () => {\n  const dirtyInput = 'test@xn--d1acpjx3f.xn--p1ai';\n  const expectedOutput = 'test@Ð´Ð¾Ð¼ÐµÐ½.Ñ€Ñ„'; // Original non-ASCII domain name\n  expect(email(dirtyInput)).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "boolean"
            },
            "jest_test_file_headers": [
                "const { boolean } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should convert string representation of true, but mishandles special symbols', () => {\n  const dirtyInput = '!true';\n  const expectedOutput = true;\n  expect(boolean(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('should convert common truthy string but fails with language encodings', () => {\n  const dirtyInput = 'çœŸ'; // 'True' in Chinese\n  const expectedOutput = true; // Hypothetical conversion\n  expect(boolean(dirtyInput)).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('should correctly convert common falsy representations', () => {\n  const dirtyInput = 'no';\n  const expectedOutput = false;\n  expect(boolean(dirtyInput)).toBe(expectedOutput);\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize (elements)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize (value, key, object)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "return function (value, key, object)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "function sanitize (elements)"
            },
            "jest_test_file_headers": [
                "const sanitizeModule = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');",
                "const sanitize = sanitizeModule();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Test for unsanitized boolean values', () => {\n    const elements = [{\n        name: { value() { return 'testBoolean'; } },\n        schema: { dataType: { value() { return 'http://www.w3.org/2001/XMLSchema#boolean'; } } }\n    }];\n\n    const userInput = {\n        testBoolean: 'false'\n    };\n\n    const sanitizationFunction = sanitize(elements);\n    const sanitizedOutput = sanitizationFunction(userInput);\n\n    expect(sanitizedOutput.testBoolean).toBe(false); // Known logical flaw, expected to fail\n});"
                },
                {
                    "signature_and_body": "test('Test for unsanitized array values', () => {\n    const elements = [{\n        name: { value() { return 'testArray'; } },\n        schema: { dataType: { value() { return 'http://www.w3.org/2001/XMLSchema#array'; } },\n                   items: { dataType: { value() { return 'http://www.w3.org/2001/XMLSchema#integer'; } } }\n        }\n    }];\n\n    const userInput = {\n        testArray: '[\"3\", \"x\"]'\n    };\n\n    const sanitizationFunction = sanitize(elements);\n    const sanitizedOutput = sanitizationFunction(userInput);\n\n    expect(sanitizedOutput.testArray).toEqual([3]); // Known logical flaw, expected to fail\n});"
                },
                {
                    "signature_and_body": "test('Test for unsanitized object values', () => {\n    const elements = [{\n        name: { value() { return 'testObject'; } },\n        schema: { dataType: { value() { return 'http://www.w3.org/2001/XMLSchema#object'; } } }\n    }];\n\n    const userInput = {\n        testObject: '{\"key\": \"value\", \"<script>\": \"alert(1)\"}'\n    };\n\n    const sanitizationFunction = sanitize(elements);\n    const sanitizedOutput = sanitizationFunction(userInput);\n\n    expect(sanitizedOutput.testObject).toEqual({ key: 'value' }); // Known logical flaw, expected to fail\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "function sanitize (value, key, object)"
            },
            "jest_test_file_headers": [
                "const sanitizeModule = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');",
                "const sanitize = sanitizeModule();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Test to check handling of special characters in strings', () => {\n    const userInput = 'a; DROP TABLE students;';\n\n    const result = sanitize(userInput);\n\n    expect(result).toBe('a; DROP TABLE students;'); // Expected fail if unsanitized input is the same as output\n});"
                },
                {
                    "signature_and_body": "test('Test for incorrect date handling', () => {\n    const userInput = '32/13/2020';\n\n    const result = sanitize(userInput);\n\n    expect(result).toBeNull(); // Expected fail if improper date does not return null or error\n});"
                },
                {
                    "signature_and_body": "test('Test to ensure inappropriate script tags are removed', () => {\n    const userInput = '<script>alert(\"Hacked!\")</script>';\n\n    const result = sanitize(userInput);\n\n    expect(result).not.toContain('<script>'); // Expected fail if script tags are not removed\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "return function (value, key, object)"
            },
            "jest_test_file_headers": [
                "const sanitizeModule = require('./fuzzed_packages/raml-sanitize/package/raml-sanitize');",
                "const sanitize = sanitizeModule();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Test array sanitization with nested dirty inputs', () => {\n    const userInput = { nestedArray: '[{\"x\": \"1000\"}, \"[{\\\"key\\\": \\\"<embedded script>\\\"}]\"]' };\n\n    const sanitizationFunction = sanitize.TYPES.array;\n    const result = sanitizationFunction(userInput);\n\n    expect(result.nestedArray).toBeInstanceOf(Array);\n    result.nestedArray.forEach(item => expect(item).not.toContain('<embedded script>'));\n});"
                },
                {
                    "signature_and_body": "test('Test object sanitization with XSS attempts', () => {\n    const userInput = { key1: \"value1\", malicious: \"<IMG SRC=j&#x61v&#x61script:alert('test2')>\" };\n\n    const sanitizationFunction = sanitize.TYPES.object;\n    const result = sanitizationFunction(userInput);\n\n    expect(Object.values(result)).not.toContainEqual(expect.stringContaining('<IMG SRC=j&#x61v&#x61script:alert'));\n});"
                },
                {
                    "signature_and_body": "test('Ensure incorrect numbers that could be misinterpreted are handled', () => {\n    const userInput = '3.1415296abc';\n\n    const sanitizationFunction = sanitize.TYPES.number;\n    const result = sanitizationFunction(userInput);\n\n    expect(result).toBeNaN(); // Expected failure if sanitized incorrectly\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "const { JSDOM } = require('jsdom');",
                "const VueSanitizeDirective = require('./index.js');",
                "const sanitizeHtml = require('sanitize-html');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass clientSideSanitization with nested event handlers', () => {\n    const dirtyInput = '<div><b onclick=\"alert(\\'XSS\\')\">Click Me</b></div>';\n    const el = new JSDOM('<div></div>').window.document.querySelector('div');\n    const modifiers = { strip: false, basic: true, inline: false, nothing: false };\n\n    VueSanitizeDirective.inserted(el, { modifiers, oldValue: '', value: dirtyInput });\n\n    // Expectation from a secure sanitization\n    expect(el.innerHTML).toBe('<div><b>Click Me</b></div>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "serverSideSanitization"
            },
            "jest_test_file_headers": [
                "const VueSanitizeDirectiveSSR = require('./index.js').VueSanitizeDirectiveSSR;",
                "const sanitizeHtml = require('sanitize-html');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass serverSideSanitization with dangerous URL', () => {\n    const dirtyInput = '<a href=\"javascript:alert(\\'XSS\\')\">Link</a>';\n    const modifiers = { strip: false, basic: true, inline: false, nothing: false };\n    const vnode = { data: { domProps: {} } };\n\n    VueSanitizeDirectiveSSR(vnode, { modifiers, value: dirtyInput });\n\n    // Expectation from a secure sanitization\n    expect(vnode.data.domProps.innerHTML).toBe('<a>Link</a>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "VueSanitizeDirectiveSSR"
            },
            "jest_test_file_headers": [
                "const VueSanitizeDirectiveSSR = require('./index.js').VueSanitizeDirectiveSSR;",
                "const sanitizeHtml = require('sanitize-html');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass VueSanitizeDirectiveSSR with malformed HTML entity', () => {\n    const dirtyInput = '<img src=x onerror=alert(\\'XSS\\')>';\n    const modifiers = { strip: false, basic: true, inline: false, nothing: false };\n    const vnode = { data: { domProps: {} } };\n\n    VueSanitizeDirectiveSSR(vnode, { modifiers, value: dirtyInput });\n\n    // Expectation from a secure sanitization\n    expect(vnode.data.domProps.innerHTML).toBe('<img src=\"x\">');\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "resolveDirectiveArguments (modifiers, input)"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization (el, { modifiers, oldValue, value })"
            },
            "jest_test_file_headers": [
                "import { directive } from '../src/index.js';",
                "import sanitizeHtml from 'sanitize-html';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitization bypass with mixed content', () => {\n  const dirtyInput = '<a href=\"javascript:alert(1)\">click me</a><img src=x onerror=alert(1)>';\n  const element = { innerHTML: '' };\n  const modifiers = { basic: true };\n  directive.update(element, { modifiers, oldValue: '', value: dirtyInput });\n  expect(sanitizeHtml(element.innerHTML, modifiers.basic ? \"FILTER_BASIC\" : '')).not.toContain('<script>');\n});"
                },
                {
                    "signature_and_body": "test('sanitization bypass with configuration', () => {\n  const dirtyInput = '<div><iframe src=\"http://evil.com\"></iframe></div>';\n  const element = { innerHTML: '' };\n  const modifiers = { nothing: true };\n  directive.update(element, { modifiers, oldValue: '', value: dirtyInput });\n  expect(element.innerHTML).toBe(''); // Expected empty because of full sanitization\n});"
                },
                {
                    "signature_and_body": "test('sanitization with nested tags', () => {\n  const dirtyInput = '<b><script>alert(\\'XSS\\')</script>Text</b>';\n  const element = { innerHTML: '' };\n  const modifiers = { basic: true };\n  directive.update(element, { modifiers, oldValue: '', value: dirtyInput });\n  expect(sanitizeHtml(element.innerHTML, \"FILTER_BASIC\")).not.toContain('<script>');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "serverSideSanitization ({ modifiers, value })"
            },
            "jest_test_file_headers": [
                "import { directive } from '../src/index.js';",
                "import sanitizeHtml from 'sanitize-html';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('server-side sanitization with mixed content', () => {\n  const dirtyInput = '<a href=\"javascript:alert(1)\">click me</a><img src=x onerror=alert(1)>';\n  const result = directive.getSSRProps({ modifiers: { basic: true }, value: dirtyInput });\n  expect(sanitizeHtml(result.innerHTML, \"FILTER_BASIC\")).not.toContain('<script>');\n});"
                },
                {
                    "signature_and_body": "test('server-side sanitization bypass with configuration', () => {\n  const dirtyInput = '<div><iframe src=\"http://evil.com\"></iframe></div>';\n  const result = directive.getSSRProps({ modifiers: { nothing: true }, value: dirtyInput });\n  expect(result.innerHTML).toBe(''); // Expected empty because of sanitization\n});"
                },
                {
                    "signature_and_body": "test('server-side sanitization with nested tags', () => {\n  const dirtyInput = '<b><script>alert(\\'XSS\\')</script>Text</b>';\n  const result = directive.getSSRProps({ modifiers: { basic: true }, value: dirtyInput });\n  expect(sanitizeHtml(result.innerHTML, \"FILTER_BASIC\")).not.toContain('<script>');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const boolean = (data) => toBoolean(data, true);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const date = (data) => toDate(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const email = (data) => normalizeEmail(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const float = (data) => toFloat(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const int = (data) => toInt(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const text = (data) => trim(escape(data));"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "text"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./fuzzed_packages/ajv-sanitizer/package');",
                "const { text } = require('./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('text sanitizer fails to escape certain special characters', () => {  \n    const dirtyInput = 'Special char: \\u202E';  // Unicode control character Right-to-Left Override\n    const expectedOutput = 'Special char: &#8238;';  // Theoretically escaped\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'text',\n            },\n        },\n    };\n    const data = {\n        value: dirtyInput,\n    };\n    ajv.validate(schema, data);\n    expect(data.value).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "email"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./fuzzed_packages/ajv-sanitizer/package');",
                "const { email } = require('./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('email sanitizer fails with unescaped input', () => {  \n    const dirtyInput = 'bademail\\n@example.com';  // New line character\n    const expectedOutput = 'bademail@example.com';  // New line removed\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'email',\n            },\n        },\n    };\n    const data = {\n        value: dirtyInput,\n    };\n    ajv.validate(schema, data);\n    expect(data.value).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "boolean"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./fuzzed_packages/ajv-sanitizer/package');",
                "const { boolean } = require('./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('boolean sanitizer bypasses on malformed boolean value', () => {\n    const dirtyInput = 'not-a-boolean';  // Inappropriately formed boolean string\n    const expectedOutput = false;  // Would expect false for non-true strings\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'boolean',\n            },\n        },\n    };\n    const data = {\n        value: dirtyInput,\n    };\n    ajv.validate(schema, data);\n    expect(data.value).toBe(expectedOutput);\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toNumber"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toInteger"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toDate"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toArray"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toObject"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toSanitization"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toNumber"
            },
            "jest_test_file_headers": [
                "const { toNumber } = require('./raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toNumber should not fail with non-numeric string containing digits', () => {\n    const dirtyInput = \"123a45\"; // Dirty input that's partially numeric\n    const expectedOutput = NaN; // toNumber should return NaN for non-numeric input\n    const actualOutput = toNumber(dirtyInput);\n    expect(actualOutput).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('toNumber should not interpret scientific notation without digits', () => {\n    const dirtyInput = \"5e\"; // Incomplete scientific notation\n    const expectedOutput = NaN; // Intended behavior should result in NaN\n    const actualOutput = toNumber(dirtyInput);\n    expect(actualOutput).toBe(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('toNumber should not convert string with leading zeros as octal', () => {\n    const dirtyInput = \"0123\"; // Leading zero, potentially octal in JS\n    const expectedOutput = 123; // Javascript evaluates this as decimal 123\n    const actualOutput = toNumber(dirtyInput);\n    expect(actualOutput).toBe(expectedOutput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "toObject"
            },
            "jest_test_file_headers": [
                "const { toObject } = require('./raml-sanitize.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('toObject should not allow JSON strings that have functions', () => {\n    const dirtyInput = '{\"key\": \"value\", \"func\": \"function() { return \\\"malicious\\\"; }\"}'; // JSON with a function as a string\n    const expectedOutput = { key: \"value\" }; // Only parse and include valid JSON properties\n    const actualOutput = toObject(dirtyInput);\n    expect(actualOutput).toEqual(expectedOutput);\n});"
                },
                {
                    "signature_and_body": "test('toObject should not parse JSON objects with hidden prototype pollution', () => {\n    const dirtyInput = '{\"__proto__\": {\"polluted\": \"yes\"}}'; // Prototype pollution payload\n    const expectedOutput = {}; // Ideally, the output should not affect Object.prototype properties\n    const actualOutput = toObject(dirtyInput); \n    expect(actualOutput.polluted).toBeUndefined(); // Check .polluted is undefined\n});"
                },
                {
                    "signature_and_body": "test('toObject should fail gracefully with malformed JSON', () => {\n    const dirtyInput = '{\"key\": \"value, \"anotherKey\": \"anotherValue\"}'; // Malformed JSON\n    expect(() => {\n        toObject(dirtyInput); // Should throw an error due to syntax issues\n    }).toThrow();\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { directive as VueSanitizeDirective } from './src/index';",
                "import sanitizeHtml from 'sanitize-html';",
                "import { JSDOM } from 'jsdom';",
                "const { window } = new JSDOM('', { url: 'http://localhost' });",
                "global.document = window.document;",
                "global.window = window;"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypasses sanitization with .nothing modifier', () => {\n    const el = document.createElement('div');\n    const modifiers = { nothing: true };\n    const oldValue = '';\n    const value = '<script>alert(\"XSS\")</script>';\n\n    VueSanitizeDirective.inserted(el, { modifiers, oldValue, value });\n\n    // Expected sanitized output should not contain <script>\n    expect(el.innerHTML).not.toBe('<script>alert(\"XSS\")</script>');\n});"
                },
                {
                    "signature_and_body": "test('bypasses inline filter via encoded JavaScript', () => {\n    const el = document.createElement('span');\n    const modifiers = { inline: true };\n    const oldValue = '';\n    const value = '<img src=\"javascript:alert(\\'XSS\\')\">';\n\n    VueSanitizeDirective.inserted(el, { modifiers, oldValue, value });\n\n    // Expected sanitized output should not contain the potentially dangerous img tag\n    expect(el.innerHTML).not.toBe('<img src=\"javascript:alert(\\'XSS\\')\">');\n});"
                },
                {
                    "signature_and_body": "test('bypasses filter with attribute encoding', () => {\n    const el = document.createElement('a');\n    const modifiers = { basic: true };\n    const oldValue = '';\n    const value = '<a href=\"javascript&#x3A;alert(\\'XSS\\')\">click me</a>';\n\n    VueSanitizeDirective.inserted(el, { modifiers, oldValue, value });\n\n    // Expected sanitized output should encode or remove javascript in href\n    expect(el.innerHTML).not.toBe('<a href=\"javascript&#x3A;alert(\\'XSS\\')\">click me</a>');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const boolean = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const date = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const email = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const float = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const int = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const text = (data)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const escape = (input)"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const trim = (input)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const boolean = (data)"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('ajv-sanitizer');",
                "const { boolean } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('boolean sanitizer should not wrongly interpret strings', () => {\n    const input = 'yes';\n    expect(boolean(input)).not.toBe(true);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const email = (data)"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('ajv-sanitizer');",
                "const { email } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('email sanitizer should reject invalid but normalized email', () => {\n    const input = 'user@-domain.com';\n    expect(email(input)).toBe(null);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
                "function_name": "const text = (data)"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('ajv-sanitizer');",
                "const { text } = require('./lib/sanitizers');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('text sanitizer should fully escape and trim inputs', () => {\n    const input = '  <div>Some text & potential XSS</div>  ';\n    expect(text(input)).toBe('&lt;div&gt;Some text &amp; potential XSS&lt;/div&gt;');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize (elements)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitization (value, key, object)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize.rule (element)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "sanitize"
            },
            "jest_test_file_headers": [
                "const ramlSanitize = require('raml-sanitize');",
                "const sanitize = ramlSanitize();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Sanitize bypass with unexpected boolean input', () => { /* Test boolean sanitization */\n  const inputs = async () => [{\n    name: { value: () => 'test_boolean' },\n    type: 'boolean',\n    value: ' \"true\" \\' // Wrapped with unexpected spaces and quotes\n  }];\n  const user = sanitize(await inputs());\n  const dirtyInput = { test_boolean: ' \"true\" \\' }; // Adversarial input\n  const result = user(dirtyInput);\n  expect(result.test_boolean).toBe(true); // Expected: true; If bypassed: ' \"true\" '\n});"
                },
                {
                    "signature_and_body": "test('Sanitize numeric edge case input', () => { /* Test number sanitization */\n  const inputs = async () => [{\n    name: { value: () => 'test_number' },\n    type: 'number',\n    value: '0.0e+2foo' // Includes both valid and invalid number parts\n  }];\n  const user = sanitize(await inputs());\n  const dirtyInput = { test_number: '0.0e+2foo' };\n  const result = user(dirtyInput);\n  expect(result.test_number).toBe(NaN); // Expected: NaN; If bypassed: '0.0e+2foo'\n});"
                },
                {
                    "signature_and_body": "test('Sanitize invalid date string input', () => { /* Test date sanitization */\n  const inputs = async () => [{\n    name: { value: () => 'test_date' },\n    type: 'date',\n    value: 'Mon, 32 Feb 2020 12:00:00 GMT' // Invalid date\n  }];\n  const user = sanitize(await inputs());\n  const dirtyInput = { test_date: 'Mon, 32 Feb 2020 12:00:00 GMT' };\n  const result = user(dirtyInput);\n  expect(result.test_date).toBeInstanceOf(Date); // Expected valid Date or error; If bypassed: Invalid Date string\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "export function VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { clientSideSanitization } from './fuzzed_packages/vue-sanitize-directive/package/src/index';",
                "import sanitizeHtml from 'sanitize-html';",
                "import { JSDOM } from 'jsdom';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Fails to sanitize with .nothing modifier allowing script tags', () => {\n  const dom = new JSDOM('<div></div>');\n  const el = dom.window.document.querySelector('div');\n  const dirtyInput = `<div><img src=x onerror=alert(1) /></div>`;\n\n  clientSideSanitization(el, { \n    modifiers: { nothing: true },\n    oldValue: '',\n    value: dirtyInput \n  });\n\n  const expectedOutput = '&lt;div&gt;&lt;img src=x onerror=alert(1) /&gt;&lt;/div&gt;';\n\n  expect(el.innerHTML).not.toBe(expectedOutput);\n  expect(el.innerHTML).toContain('<img src=x onerror=alert(1) />');  \n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { clientSideSanitization } from './fuzzed_packages/vue-sanitize-directive/package/src/index';",
                "import sanitizeHtml from 'sanitize-html';",
                "import { JSDOM } from 'jsdom';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Fails to sanitize with .inline modifier leaking style attributes', () => {\n  const dom = new JSDOM('<span></span>');\n  const el = dom.window.document.querySelector('span');\n  const dirtyInput = `<span style=\"color: red; expression(alert(1));\">Test</span>`;\n\n  clientSideSanitization(el, { \n    modifiers: { inline: true },\n    oldValue: '', \n    value: dirtyInput\n  });\n\n  const expectedOutput = '&lt;span style=\"color: red;&lt;/span&gt;Test';\n\n  expect(el.innerHTML).not.toBe(expectedOutput);\n  expect(el.innerHTML).toContain('expression(alert(1))');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { clientSideSanitization } from './fuzzed_packages/vue-sanitize-directive/package/src/index';",
                "import sanitizeHtml from 'sanitize-html';",
                "import { JSDOM } from 'jsdom';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Fails to sanitize with FILTER_BASIC by bypassing script removal', () => {\n  const dom = new JSDOM('<a></a>');\n  const el = dom.window.document.querySelector('a');\n  const dirtyInput = `<a href=\"javascript:alert(1)\">Click me</a>`;\n\n  clientSideSanitization(el, {\n    modifiers: { basic: true },\n    oldValue: '',\n    value: dirtyInput\n  });\n\n  const expectedOutput = '&lt;a&gt;Click me&lt;/a&gt;';\n\n  expect(el.innerHTML).not.toBe(expectedOutput);\n  expect(el.innerHTML).toContain('javascript:alert(1)');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const boolean = (data) => toBoolean(data, true);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const date = (data) => toDate(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const email = (data) => normalizeEmail(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const float = (data) => toFloat(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const int = (data) => toInt(data);"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "const text = (data) => trim(escape(data));"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "ajvSanitizer"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./package');",
                "const { expect } = require('@jest/globals');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('text sanitizer improperly sanitizes script tags', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'text',\n            },\n        },\n    };\n\n    const data = {\n        value: '   <script>alert(\"XSS\")<\\/script>   ',\n    };\n\n    ajv.validate(schema, data);\n\n    // Expecting the tags to be completely removed and whitespace to be trimmed\n    expect(data.value).toBe('alert(\\\"XSS\\\")');\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "ajvSanitizer"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./package');",
                "const { expect } = require('@jest/globals');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('email sanitizer mishandles IP address emails', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'email',\n            },\n        },\n    };\n\n    const data = {\n        value: 'test.email@[123.123.123.123]'\n    };\n\n    ajv.validate(schema, data);\n\n    // Expecting this to remain unchanged as it should fail sanitization\n    expect(data.value).toBe(''); // Assuming a policy to blank invalid emails\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "ajvSanitizer"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./package');",
                "const { expect } = require('@jest/globals');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('int sanitizer improperly handles scientific notation', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'int',\n            },\n        },\n    };\n\n    const data = {\n        value: '123.45e6'\n    };\n\n    ajv.validate(schema, data);\n\n    // Since `int` should convert input to integer, expect the mishandling of float\n    expect(data.value).toBe('123');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitize (value, key, object)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "function sanitization (value, key, object)"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "return function (value, key, object)"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "function sanitize (value, key, object)"
            },
            "jest_test_file_headers": [
                "const wap = require('webapi-parser').WebApiParser;",
                "const sanitize = require('../package/raml-sanitize')();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should not allow non-array JSON string to bypass array sanitization', async () => {\n    const ramlStr = `\n      #%RAML 1.0\n      title: API with Types\n      types:\n        User:\n          type: object\n          properties:\n            data: array\n    `;\n    const model = await wap.raml10.parse(ramlStr);\n    const properties = model.declares[0].properties;\n    const user = sanitize(properties);\n    const dirtyInput = '{\"name\":\"John\"}'; // input not an array\n    const result = user({ data: dirtyInput });\n    expect(result.data).not.toEqual(dirtyInput);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "function sanitize (value, key, object)"
            },
            "jest_test_file_headers": [
                "const wap = require('webapi-parser').WebApiParser;",
                "const sanitize = require('../package/raml-sanitize')();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should convert known false representation strings to false', async () => {\n    const ramlStr = `\n      #%RAML 1.0\n      title: API with Types\n      types:\n        User:\n          type: object\n          properties:\n            isActive: boolean\n    `;\n    const model = await wap.raml10.parse(ramlStr);\n    const properties = model.declares[0].properties;\n    const user = sanitize(properties);\n    const dirtyInput = 'yes'; // non-standard truthy value\n    const result = user({ isActive: dirtyInput });\n    expect(result.isActive).not.toBeTruthy();\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "function sanitize (value, key, object)"
            },
            "jest_test_file_headers": [
                "const wap = require('webapi-parser').WebApiParser;",
                "const sanitize = require('../package/raml-sanitize')();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should convert non-numeric strings to NaN', async () => {\n    const ramlStr = `\n      #%RAML 1.0\n      title: API with Types\n      types:\n        User:\n          type: object\n          properties:\n            age: number\n    `;\n    const model = await wap.raml10.parse(ramlStr);\n    const properties = model.declares[0].properties;\n    const user = sanitize(properties);\n    const dirtyInput = '123abc'; // non-numeric input\n    const result = user({ age: dirtyInput });\n    expect(result.age).toBe(NaN);\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "export function VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { directive } from './fuzzed_packages/vue-sanitize-directive/package/src/index.js';",
                "import { mount } from '@vue/test-utils';",
                "import Vue from 'vue';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('clientSideSanitization allows unexpected <script> tag with FILTER_NOTHING', () => { const wrapper = mount({ directives: { sanitize: directive }, template: \"<span v-sanitize.nothing='dirtyInput'></span>\", data() { return { dirtyInput: '<script>alert(1)</script>' } } }); expect(wrapper.html()).not.toContain('<script>alert(1)</script>'); });"
                },
                {
                    "signature_and_body": "test('clientSideSanitization allows inline-js in styles with FILTER_INLINE', () => { const wrapper = mount({ directives: { sanitize: directive }, template: \"<span v-sanitize.inline='dirtyInput'></span>\", data() { return { dirtyInput: '<span style=\\\"background-image: url(javascript:alert(1))\\\">Link</span>' } } }); expect(wrapper.html()).not.toContain('javascript:alert(1)'); });"
                },
                {
                    "signature_and_body": "test('clientSideSanitization bypasses FILTER_STRIP allowing HTML tags', () => { const wrapper = mount({ directives: { sanitize: directive }, template: \"<span v-sanitize.strip='dirtyInput'></span>\", data() { return { dirtyInput: '<img src=\\\"x\\\" onerror=\\\"alert(1)\\\">' } } }); expect(wrapper.html()).not.toContain('<img'); });"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function clientSideSanitization (el, { modifiers, oldValue, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function serverSideSanitization ({ modifiers, value })"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "function VueSanitizeDirectiveSSR (vnode, { modifiers, value })"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import sanitizeHtml from 'sanitize-html';",
                "import { directive } from './fuzzed_packages/vue-sanitize-directive/package/src/index.js';",
                "import { mount } from '@vue/test-utils';",
                "import Vue from 'vue';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('clientSideSanitization allows script tag with malformed attributes', () => {\n    const el = document.createElement('div');\n    const unsafeHTML = \"<script x=\\"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "clientSideSanitization"
            },
            "jest_test_file_headers": [
                "import { directive } from './fuzzed_packages/vue-sanitize-directive/package/src/index.js';",
                "import { mount } from '@vue/test-utils';",
                "import Vue from 'vue';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Adversarial input bypasses .nothing modifier', () => {\n    const wrapper = mount({\n      template: `<div v-sanitize.nothing=\"\\'<img src=\\\"javascript:alert(\\\"xss\\\")\\\">\\'\"></div>`\n    }, {\n      global: {\n        directives: {\n          sanitize: directive\n        }\n      }\n    });\n\n    // Expectation: Tags and attributes should be sanitized. The test fails if it's not.\n    expect(wrapper.html()).toBe('<div>&lt;img src=&quote;javascript:alert(&quote;xss&quote;)&gt;</div>');\n});\n"
                },
                {
                    "signature_and_body": "test('Adversarial input bypasses .inline modifier', () => {\n    const wrapper = mount({\n      template: `<div v-sanitize.inline=\"\\'<span style=\\\"background-image: url(\\\"javascript:alert(\\\\\\'xss\\\\\\')\\\")\\\">\\'></span>`\n    }, {\n      global: {\n        directives: {\n          sanitize: directive\n        }\n      }\n    });\n\n    // Expectation: Javascript in styles should be sanitized out. The test fails if it's not.\n    expect(wrapper.html()).toBe('<div>&lt;span&gt;&lt;/span&gt;</div>');\n});\n"
                },
                {
                    "signature_and_body": "test('Adversarial input bypasses .basic modifier', () => {\n    const wrapper = mount({\n      template: `<div v-sanitize.basic=\"\\'<a onmouseover=\\\"alert(\\\"xss\\\")\\\">\\'></a>`\n    }, {\n      global: {\n        directives: {\n          sanitize: directive\n        }\n      }\n    });\n\n    // Expectation: Unallowed attributes should be removed. The test fails if there are still unallowed attributes.\n    expect(wrapper.html()).toBe('<div>&lt;a&gt;&lt;/a&gt;</div>');\n});\n"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
            "function_name": "ajvSanitizer"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "boolean"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "date"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "email"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "escape"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "float"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "int"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "text"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "trim"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
                "function_name": "ajvSanitizer"
            },
            "jest_test_file_headers": [
                "const Ajv = require('ajv');",
                "const ajvSanitizer = require('./fuzzed_packages/ajv-sanitizer/package/index.js');",
                "const assert = require('assert');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('text sanitizer should escape script tags', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'text',\n            },\n        },\n    };\n\n    const data = { value: '<script>alert(1)</script>' };\n    ajv.validate(schema, data);\n\n    // Expect it to escape the script tags\n    expect(data.value).toBe('&lt;script&gt;alert(1)&lt;/script&gt;');\n});"
                },
                {
                    "signature_and_body": "test('email sanitizer should normalize odd email formats', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            value: {\n                type: 'string',\n                sanitize: 'email',\n            },\n        },\n    };\n\n    const data = { value: 'weird..email@domain..com' };\n    ajv.validate(schema, data);\n\n    // Expect it to correctly normalize the email\n    expect(data.value).toBe('weird.email@domain.com');\n});"
                },
                {
                    "signature_and_body": "test('sanitize deeply nested properties', () => {\n    const ajv = new Ajv();\n    ajvSanitizer(ajv);\n\n    const schema = {\n        type: 'object',\n        properties: {\n            nested: {\n                type: 'object',\n                properties: {\n                    value: {\n                        type: 'string',\n                        sanitize: 'text',\n                    },\n                },\n            },\n        },\n    };\n\n    const data = { nested: { value: '<img src=x onerror=alert(1)>' } };\n    ajv.validate(schema, data);\n\n    // Expect the sanitizer to properly escape the HTML\n    expect(data.nested.value).toBe('&lt;img src=x onerror=alert(1)&gt;');\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "module.exports"
        },
        {
            "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
            "function_name": "toSanitization"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/raml-sanitize/package/raml-sanitize.js",
                "function_name": "module.exports"
            },
            "jest_test_file_headers": [
                "const sanitize = require('../fuzzed_packages/raml-sanitize/package/raml-sanitize.js')();"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass boolean sanitization', () => {\n  const properties = [{ name: 'flag', type: 'boolean' }];\n  const sanitizer = sanitize(properties);\n  const dirtyInput = 'truthy_value'; // Should not be accepted as `true`\n  const result = sanitizer({ flag: dirtyInput });\n  expect(result.flag).toBe(false);\n});"
                },
                {
                    "signature_and_body": "test('bypass number sanitization with special characters', () => {\n  const properties = [{ name: 'amount', type: 'number' }];\n  const sanitizer = sanitize(properties);\n  const dirtyInput = '1e1000'; // Represents Infinity, should not be a number\n  const result = sanitizer({ amount: dirtyInput });\n  expect(result.amount).toBe(NaN);\n});"
                },
                {
                    "signature_and_body": "test('bypass object sanitization with complex string', () => {\n  const properties = [{ name: 'settings', type: 'object' }];\n  const sanitizer = sanitize(properties);\n  const dirtyInput = '{ \"foo\": [ { \"bar\": \"baz\" } ]'; // Malformed JSON string\n  const result = sanitizer({ settings: dirtyInput });\n  expect(result.settings).toBe(null); // Should be null since it can't parse\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/graphql-scalar/package/lib/float.js",
            "function_name": "createFloatScalar"
        },
        {
            "file_name": "./fuzzed_packages/graphql-scalar/package/lib/int.js",
            "function_name": "createIntScalar"
        },
        {
            "file_name": "./fuzzed_packages/graphql-scalar/package/lib/string.js",
            "function_name": "createStringScalar"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/graphql-scalar/package/lib/string.js",
                "function_name": "createStringScalar"
            },
            "jest_test_file_headers": [
                "import { createStringScalar } from 'graphql-scalar';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitization bypass with special characters', () => {\n   const stringScalar = createStringScalar({\n       name: 'TestString',\n       pattern: /^[a-zA-Z]+$/\n   });\n   const dirtyInput = 'validString123'; // Bypasses alphabetic check by including numbers\n   const expectedOutput = null; // Should have been sanitized to null due to pattern\n   expect(stringScalar.parseValue(dirtyInput, null)).toBe(expectedOutput);\n);"
                },
                {
                    "signature_and_body": "test('bypass collapseWhitespace logic', () => {\n   const stringScalar = createStringScalar({\n       name: 'TrimAndCollapse',\n       collapseWhitespace: true\n   });\n   const dirtyInput = 'Whitespace   unchanged  '; // Crafted to bypass logic\n   const expectedOutput = 'Whitespace unchanged'; // Expected trim and collapse\n   expect(stringScalar.parseValue(dirtyInput, null)).toBe(expectedOutput);\n);"
                },
                {
                    "signature_and_body": "test('sanitize function bypass', () => {\n   const sanitizeFunction = jest.fn(value => { if (value.includes(\"unsafe\")) return null; return value; });\n   const stringScalar = createStringScalar({\n       name: 'SafeString',\n       sanitize: sanitizeFunction\n   });\n   const dirtyInput = 'This is unsafe'; // Intended to be sanitized to null\n   const expectedOutput = null;\n   expect(stringScalar.parseValue(dirtyInput, null)).toBe(expectedOutput);\n);"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/graphql-scalar/package/lib/int.js",
                "function_name": "createIntScalar"
            },
            "jest_test_file_headers": [
                "import { createIntScalar } from 'graphql-scalar';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('integer coercion bypass', () => {\n   const intScalar = createIntScalar({\n       name: 'SafeInteger',\n       coerce: value => parseInt(value),\n       validate: value => value === Math.floor(value)\n   });\n   const dirtyInput = '42.9999999'; // Coercion to 42 should not pass validation\n   const expectedOutput = null; // Should fail due to unsafe integer coerce\n   expect(intScalar.parseValue(dirtyInput, null)).toBe(expectedOutput);\n);"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/graphql-scalar/package/lib/float.js",
                "function_name": "createFloatScalar"
            },
            "jest_test_file_headers": [
                "import { createFloatScalar } from 'graphql-scalar';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('boundary float value bypass', () => {\n   const floatScalar = createFloatScalar({\n       name: 'RestrictedFloat',\n       maximum: 100.0\n   });\n   const dirtyInput = '100.0000001'; // Intended to surpass boundary as sanitized\n   const expectedOutput = null; // Should not pass maximum limit\n   expect(floatScalar.parseValue(dirtyInput, null)).toBe(expectedOutput);\n);"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/disinfect/package/lib/index.js",
            "function_name": "internals.sanitize"
        },
        {
            "file_name": "./fuzzed_packages/disinfect/package/lib/index.js",
            "function_name": "internals.deleteEmpty"
        },
        {
            "file_name": "./fuzzed_packages/disinfect/package/lib/index.js",
            "function_name": "internals.deleteWhitespace"
        },
        {
            "file_name": "./fuzzed_packages/disinfect/package/lib/index.js",
            "function_name": "internals.disinfect"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/disinfect/package/lib/index.js",
                "function_name": "internals.sanitize"
            },
            "jest_test_file_headers": [
                "const { plugin } = require('./fuzzed_packages/disinfect/package/lib');",
                "const sanitizeFunction = plugin.register;"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Sanitize nested objects with malicious scripts', () => {\n    const dirtyInput = {\n        level1: {\n            level2: {\n                script: '<script>alert(1)</script>'\n            }\n        }\n    };\n    const expectedOutput = {\n        level1: {\n            level2: {\n                script: '&lt;script&gt;alert(1)&lt;/script&gt;'\n            }\n        }\n    };\n    expect(sanitizeFunction(dirtyInput, { disinfectPayload: true }).level1.level2.script).toBe(expectedOutput.level1.level2.script);\n});"
                },
                {
                    "signature_and_body": "test('Sanitize inputs with encoded sequences', () => {\n    const dirtyInput = {\n        input: \"%3Cscript%3Ealert('x')%3C/script%3E\"\n    };\n    const expectedOutput = {\n        input: \"&lt;script&gt;alert('x')&lt;/script&gt;\"\n    };\n    expect(sanitizeFunction(dirtyInput, { disinfectPayload: true }).input).toBe(expectedOutput.input);\n});"
                },
                {
                    "signature_and_body": "test('Sanitize HTML tags with excessive whitespace', () => {\n    const dirtyInput = {\n        html: '   <script>   alert(\\'danger\\');   </script>   '\n    };\n    const expectedOutput = {\n        html: '   &lt;script&gt;   alert(\\'danger\\');   &lt;/script&gt;   '\n    };\n    expect(sanitizeFunction(dirtyInput, { disinfectPayload: true, deleteWhitespace: false }).html).toBe(expectedOutput.html);\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "clientSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "serverSideSanitization"
        },
        {
            "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
            "function_name": "VueSanitizeDirectiveSSR"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/vue-sanitize-directive/package/src/index.js",
                "function_name": "resolveDirectiveArguments"
            },
            "jest_test_file_headers": [
                "import { clientSideSanitization, serverSideSanitization, VueSanitizeDirectiveSSR } from '../src/index';",
                "import Vue from 'vue';",
                "import { mount } from '@vue/test-utils';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('FILTER_NOTHING allows unsanitized script tags', () => {\n    const mockElement = document.createElement('div');\n    clientSideSanitization(mockElement, { modifiers: { nothing: true }, oldValue: '', value: '<script>alert(\\'test\\')</script>' });\n    expect(mockElement.innerHTML).toBe('&lt;script&gt;alert(\\'test\\')&lt;/script&gt;'); // Expected sanitized output\n});"
                },
                {
                    "signature_and_body": "test('FILTER_INLINE allows style attributes with javascript URLs', () => {\n    const mockElement = document.createElement('span');\n    clientSideSanitization(mockElement, { modifiers: { inline: true }, oldValue: '', value: '<span style=\"background-image: url(javascript:alert(\\'xss\\'))\">image</span>' });\n    expect(mockElement.innerHTML).toBe('<span>image</span>'); // Expected sanitized output, without style\n});"
                },
                {
                    "signature_and_body": "test('FILTER_BASIC unexpected behavior with malformed tags', () => {\n    const mockElement = document.createElement('div');\n    clientSideSanitization(mockElement, { modifiers: { basic: true }, oldValue: '', value: '<img \"\"\">' });\n    expect(mockElement.innerHTML).toBe(''); // Expected sanitized output, stripping malformed tags completely\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/env-sanitize/package/jest.config.js",
            "function_name": "transform"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/env-sanitize/package/index.js",
                "function_name": "env"
            },
            "jest_test_file_headers": [
                "// Import the env-sanitize module for testing",
                "const env = require('env-sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('asInt should not sanitize non-standard number representations', () => {\n    // Using hexadecimal input which should be considered invalid\n    process.env.INT_KEY = '0x10';\n    expect(() => {\n        env('INT_KEY', (x) => x.asInt());\n    }).toThrow();\n});"
                },
                {
                    "signature_and_body": "test('asRegex should not sanitize strings improperly anchored', () => {\n    // Using input with special characters that might bypass regex sanitization\n    process.env.ONLY_NUMBERS_KEY = '*123*';\n    expect(() => {\n        env('ONLY_NUMBERS_KEY', (x) => x.asRegex(/^\\d+$/));\n    }).toThrow();\n});"
                },
                {
                    "signature_and_body": "test('asJson should not accept malformed JSON structures', () => {\n    // Using partially malformed JSON input\n    process.env.JSON_KEY = \"{'key': undefined}\";\n    expect(() => {\n        env('JSON_KEY', (x) => x.asJson());\n    }).toThrow();\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/express-validate/package/index.js",
            "function_name": "req.filter"
        },
        {
            "file_name": "./fuzzed_packages/express-validate/package/index.js",
            "function_name": "req.check"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/express-validate/package/index.js",
                "function_name": "req.filter"
            },
            "jest_test_file_headers": [
                "const expressValidate = require('./fuzzed_packages/express-validate/package');",
                "const httpMocks = require('node-mocks-http');",
                "const { expect } = require('@jest/globals');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('bypass xss filter with unclosed tag', () => {\n    const req = httpMocks.createRequest({\n        body: { mail: '<div><p>Hello' }\n    });\n    const res = httpMocks.createResponse();\n    expressValidate(req, res, () => {});\n\n    const sanitized = req.filter('mail').xss();\n    expect(sanitized).toBe('&lt;div&gt;&lt;p&gt;Hello'); // Expect tags to be properly closed\n});"
                },
                {
                    "signature_and_body": "test('bypass xss filter using script blocks', () => {\n    const req = httpMocks.createRequest({\n        body: { mail: '<IMG SRC=\"javascript:alert(\\'XSS\\');\">' }\n    });\n    const res = httpMocks.createResponse();\n    expressValidate(req, res, () => {});\n\n    const sanitized = req.filter('mail').xss();\n    expect(sanitized).toBe(''); // Expect scripts to be stripped and result empty\n});"
                },
                {
                    "signature_and_body": "test('bypass xss filter using encoded entities', () => {\n    const req = httpMocks.createRequest({\n        body: { mail: '<<script>>alert(String.fromCharCode(88,83,83))</script>' }\n    });\n    const res = httpMocks.createResponse();\n    expressValidate(req, res, () => {});\n\n    const sanitized = req.filter('mail').xss();\n    expect(sanitized).toBe('&lt;&lt;script&gt;&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt;'); // Expect nested encoding to be handled\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/graphql-input-string/package/lib/index.js",
            "function_name": "default"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/graphql-input-string/package/lib/index.js",
                "function_name": "default"
            },
            "jest_test_file_headers": [
                "import GraphQLInputString from 'graphql-input-string';",
                "import { GraphQLSchema, graphql } from 'graphql';",
                "import { makeExecutableSchema } from '@graphql-tools/schema';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('should sanitize input by trimming both sides and removing multiple spaces', async () => {\n  const CustomInputString = GraphQLInputString({\n    name: 'CustomString',\n    trim: true,\n    collapseWhitespace: true\n  });\n\n  const schema = makeExecutableSchema({\n    typeDefs: `\n      type Query {\n        input(name: String): String\n      }\n    `,\n    resolvers: {\n      Query: {\n        input: (_, { name }) => name\n      }\n    }\n  });\n\n  const query = `{\n    input(name: \"     malicious    input   \")\n  }`;\n\n  const result = await graphql(schema, query);\n  expect(result.data.input).toBe(\"malicious input\");\n});"
                },
                {
                    "signature_and_body": "test('should convert input to uppercase and sanitize correctly', async () => {\n  const CustomInputString = GraphQLInputString({\n    name: 'UppercaseString',\n    upperCase: true,\n    trim: true\n  });\n\n  const schema = makeExecutableSchema({\n    typeDefs: `\n      type Query {\n        input(name: String): String\n      }\n    `,\n    resolvers: {\n      Query: {\n        input: (_, { name }) => name\n      }\n    }\n  });\n\n  const query = `{\n    input(name: \"   malicious\")\n  }`;\n\n  const result = await graphql(schema, query);\n  expect(result.data.input).toBe(\"MALICIOUS\");\n});"
                },
                {
                    "signature_and_body": "test('should handle newlines and sanitize to single line', async () => {\n  const CustomInputString = GraphQLInputString({\n    name: 'SingleLineString',\n    singleline: true,\n    collapseWhitespace: true\n  });\n\n  const schema = makeExecutableSchema({\n    typeDefs: `\n      type Query {\n        input(name: String): String\n      }\n    `,\n    resolvers: {\n      Query: {\n        input: (_, { name }) => name\n      }\n    }\n  });\n\n  const query = `{\n    input(name: \"multi\\nline\\nmalicious\")\n  }`;\n\n  const result = await graphql(schema, query);\n  expect(result.data.input).toBe(\"multi line malicious\");\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/express-autosanitizer/package/lib/express-autosanitizer.js",
            "function_name": "middlewareObj.all"
        },
        {
            "file_name": "./fuzzed_packages/express-autosanitizer/package/lib/express-autosanitizer.js",
            "function_name": "middlewareObj.allUnsafe"
        },
        {
            "file_name": "./fuzzed_packages/express-autosanitizer/package/lib/express-autosanitizer.js",
            "function_name": "middlewareObj.route"
        },
        {
            "file_name": "./fuzzed_packages/express-autosanitizer/package/lib/express-autosanitizer.js",
            "function_name": "middlewareObj.routeUnsafe"
        },
        {
            "file_name": "./fuzzed_packages/express-autosanitizer/package/lib/express-autosanitizer.js",
            "function_name": "middlewareObj.sanitizeIt"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/express-autosanitizer/package/lib/express-autosanitizer.js",
                "function_name": "middlewareObj.sanitizeIt"
            },
            "jest_test_file_headers": [
                "const middlewareObj = require('../package/lib/express-autosanitizer');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitizeIt should escape HTML tags in strings correctly', () => {\n  const input = '<img src=x onerror=alert(1)>';\n  const result = middlewareObj.sanitizeIt(input);\n  expect(result).toBe('&lt;img src=x onerror=alert(1)&gt;');\n});"
                },
                {
                    "signature_and_body": "test('sanitizeIt should handle encoded HTML entities properly', () => {\n  const input = '&lt;svg onload=alert(1)&gt;';\n  const result = middlewareObj.sanitizeIt(input);\n  expect(result).toBe('&amp;lt;svg onload=alert(1)&amp;gt;');\n});"
                },
                {
                    "signature_and_body": "test('sanitizeIt should recursively sanitize nested objects', () => {\n  const input = { user: { profile: { script: '<script>alert(1)</script>' } } };\n  const result = middlewareObj.sanitizeIt(input);\n  const expected = { user: { profile: { script: '&lt;script&gt;alert(1)&lt;/script&gt;' } } };\n  expect(result).toEqual(expected);\n});"
                }
            ]
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/index.js",
            "function_name": "ajvSanitizer"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "boolean"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "date"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "email"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "escape"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "float"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "int"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "text"
        },
        {
            "file_name": "./fuzzed_packages/ajv-sanitizer/package/lib/sanitizers.js",
            "function_name": "trim"
        }
    ]
}

files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "basic"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "extern"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "required"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "requireArray"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "notEqual"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isInt"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isString"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isFunction"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isArray"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "listOf"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "notNullable"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "immutable"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "reqIfHasAny"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "reqIfHasAll"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "notReqIfHasAny"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "notReqIfHasAll"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isLength"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isLengthUnicode"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isIn"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isBool"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isInRangeInclusive"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "defined"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "min"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "minLength"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "maxLength"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isEqualTo"
        },
        {
            "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
            "function_name": "isValidEmail"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/awesomize/package/lib/check.js",
                "function_name": "basic"
            },
            "jest_test_file_headers": [
                "const Awesomize = require('awesomize');",
                "const _ = require('ramda');",
                "const { expect } = require('chai');",
                "const Check = require('../../lib/check');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('isString allows input with non-character entities', () => {\n    const spec = Awesomize({}, (v) => ({\n        foo: {\n            sanitize: [_.trim],\n            validate: [v.isString]\n        }\n    }));\n\n    const dirtyInput = \"123<abc>\"; // Non-typical string that should be sanitized but isnâ€™t due to non-character entities.\n    return spec({foo: dirtyInput}).then((result) => {\n        expect(result.data.foo).not.toEqual(dirtyInput);\n    }).catch(err => {\n        if (err) {\n            console.error(\"Test failed as expected:\", err);\n        }\n    });\n})"
                },
                {
                    "signature_and_body": "test('isIn allows unlisted special characters', () => {\n    const spec = Awesomize({}, (v) => ({\n        foo: {\n            sanitize: [_.identity],\n            validate: [v.isIn(['a', 'b', 'c', 'd', 'e'])]\n        }\n    }));\n\n    const dirtyInput = \"@\"; // Assumes '@' shouldnâ€™t be accepted but bypasses due to missing list validation\n    return spec({foo: dirtyInput}).then((result) => {\n        expect(result.data.foo).not.toEqual(dirtyInput);\n    }).catch(err => {\n        if (err) {\n            console.error(\"Test failed as expected:\", err);\n        }\n    });\n})"
                },
                {
                    "signature_and_body": "test('isArray fails to reject dirty string input', () => {\n    const spec = Awesomize({}, (v) => ({\n        foo: {\n            sanitize: [Array.isArray],\n            validate: [v.isArray]\n        }\n    }));\n\n    const dirtyInput = \"notAnArray\"; // A string that should be caught but isnâ€™t due to logical checks\n    return spec({foo: dirtyInput}).then((result) => {\n        expect(result.data.foo).not.toEqual(dirtyInput);\n    }).catch(err => {\n        if (err) {\n            console.error(\"Test failed as expected:\", err);\n        }\n    });\n})"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "src/sanitize.ts",
            "function_name": "sanitize"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "src/sanitize.ts",
                "function_name": "sanitize"
            },
            "jest_test_file_headers": [
                "import sanitize, { OR } from 'sanitize-against';"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('Bypass with Optional and Default Values', () => {\n    const pattern = {\n        'username': String,\n        'profile': {\n            'age?': Number,\n            'role': 'user'  // Default value\n        }\n    };\n    const against = sanitize(pattern);\n    const input = {\n        username: 'malicious_user',\n        profile: { role: undefined }  // Intentionally setting to invoke defaults\n    };\n    const result = against(input);\n    // Expect 'role' to be defaulted to 'user', but check if raw data passed\n    expect(result.profile.role).not.toBe('user');  // this should fail if result is user or unsanitized\n});"
                },
                {
                    "signature_and_body": "test('Improper OR Handling for String Numbers', () => {\n    const pattern = OR(Number, String);\n    const against = sanitize(pattern);\n    const input = \"123abc\";  // String that looks like number but should fail\n    const result = against(input);\n    expect(result).toThrow();  // Should throw but passes\n});"
                },
                {
                    "signature_and_body": "test('Prototype Pollution Exploit', () => {\n    const pattern = {\n        name: String,\n        details: {\n            address: String\n        }\n    };\n    const against = sanitize(pattern);\n    const input = {\n        name: 'John Doe',\n        '__proto__': { admin: true },  // Prototype pollution attempt\n        details: {\n            address: '123 Unknown St'\n        }\n    };\n    const result = against(input);\n    // Check if prototype pollution is reverted\n    expect({}.admin).toBe(undefined);  // Should be undefined but polluted\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/jstring/package/index.js",
            "function_name": "removeTags"
        },
        {
            "file_name": "./fuzzed_packages/jstring/package/index.js",
            "function_name": "handleString"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/jstring/package/index.js",
                "function_name": "removeTags"
            },
            "jest_test_file_headers": [
                "const jstring = require('jstring');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('removeTags should remove all script tags, even when malformed', () => {\n    const dirtyInput = 'Some text<script>alert(\"XSS\")</script>more text<script>incomplete;';\n    const sanitized = jstring.removeTags(dirtyInput);\n    // The expected result assuming the function works correctly would be:\n    const expected = 'Some textmore text';\n    // However, due to the vulnerability, the result might still contain script tags.\n    expect(sanitized).toBe(expected);\n});"
                },
                {
                    "signature_and_body": "test('removeTags handles malformed exceptions gracefully', () => {\n    const dirtyInput = '<div><scr<script>ipt>alert(\"XSS\")</div>';\n    const except = ['scr<script>ipt'];  // Intentionally malformed exception\n    const sanitized = jstring.removeTags(dirtyInput, except);\n    // Ideally, malformed exceptions should not cause script tags to persist\n    const expected = '<div></div>';\n    expect(sanitized).toBe(expected);\n});"
                },
                {
                    "signature_and_body": "test('handleString fails to remove nested script tags when exception is given', () => {\n    const task = { removeTags: ['div'], replace: ['XSS', ''] };\n    const dirtyInput = '<div>XSS<script>alert(\"malicious\")</script></div>';\n    const result = jstring.handleString(dirtyInput, task);\n    const expected = 'XSS'; //Doesn't expect malicious code due to sanitize but does expect content\n    expect(result).toBe(expected);\n});"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/jstring/package/index.js",
                "function_name": "handleString"
            },
            "jest_test_file_headers": [
                "const jstring = require('jstring');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('handleString with complex tasks leaves script tag intact', () => {\n    const task = { removeTags: null, replace: ['<script>', '', true] };\n    const dirtyInput = 'Clean <script>alert(\"XSS\")</script>';\n    const sanitized = jstring.handleString(dirtyInput, task);\n    const expected = 'Clean ';\n    expect(sanitized).toBe(expected);\n});"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": [
        {
            "file_name": "./fuzzed_packages/validator-as-promised/package/index.js",
            "function_name": "isAlpha"
        },
        {
            "file_name": "./fuzzed_packages/validator-as-promised/package/index.js",
            "function_name": "isAlphaAsync"
        },
        {
            "file_name": "./fuzzed_packages/validator-as-promised/package/index.js",
            "function_name": "custom"
        }
    ]
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "./fuzzed_packages/validator-as-promised/package/index.js",
                "function_name": "isAlphaAsync"
            },
            "jest_test_file_headers": [
                "const validator = require('../index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('isAlphaAsync should fail with Unicode visually-deceptive chars', () => {\n  const input = 'ðšŠbcð’Ÿ';  // Use Unicode chars that look like alpha but aren't in ASCII\n  return validator.isAlphaAsync('should be alpha chars only', input)\n    .then(() => {\n      throw new Error('Validation bypassed. Input should not pass.');\n    })\n    .catch((err) => {\n      expect(err.message).toBe('should be alpha chars only');\n    });\n})"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/validator-as-promised/package/index.js",
                "function_name": "custom"
            },
            "jest_test_file_headers": [
                "const validator = require('../index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('custom should fail with crafted JSON object', () => {\n  const callback = (val) => JSON.stringify(val) === '{\"malicious\":true}';\n  const input = { malicious: true, extra: 'data' };\n  return validator.custom('should match exact structure', callback, input)\n    .then(() => {\n      throw new Error('Validation bypassed. Input should not pass.');\n    })\n    .catch((err) => {\n      expect(err.message).toBe('should match exact structure');\n    });\n})"
                }
            ]
        },
        {
            "function": {
                "file_name": "./fuzzed_packages/validator-as-promised/package/index.js",
                "function_name": "custom"
            },
            "jest_test_file_headers": [
                "const validator = require('../index.js');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('custom should fail with repetitive patterns', () => {\n  const callback = (str) => /^a+b+$/.test(str);\n  const input = 'aaaabbb';  // Expected for /^a+b+$/ but can bypass with excessive length interpretation\n  return validator.custom('pattern must be a+b+', callback, input)\n    .then(() => {\n      throw new Error('Validation bypassed. Input should not pass.');\n    })\n    .catch((err) => {\n      expect(err.message).toBe('pattern must be a+b+');\n    });\n})"
                }
            ]
        }
    ]
}

------------
files and functions that appear vulnerable:{
    "functions": []
}

harness:{
    "test_suites": [
        {
            "function": {
                "file_name": "sanitize.js",
                "function_name": "sanitizeInput"
            },
            "jest_test_file_headers": [
                "const { sanitizeInput } = require('./sanitize');"
            ],
            "jest_sanitization_test_cases": [
                {
                    "signature_and_body": "test('sanitizeInput allows scripts through with incomplete escaping', () => {\n  const input = \"<script>console.log('XSS')</script>\";\n  const output = sanitizeInput(input);\n  // Expecting it to escape the script tags, but due to a bug, it fails to do so.\n  expect(output).not.toBe('<script>console.log(\\'XSS\\')</script>');\n});"
                },
                {
                    "signature_and_body": "test('sanitizeInput mishandles unicode characters', () => {\n  const input = \"<div>ÐŸÑ€Ð¸Ð²ÐµÑ‚<script>alert('XSS')</script></div>\";\n  const output = sanitizeInput(input);\n  // Expecting it to escape script tags, but due to a bug, it leaves them intact.\n  expect(output).not.toBe('<div>ÐŸÑ€Ð¸Ð²ÐµÑ‚<script>alert(\\'XSS\\')</script></div>');\n});"
                },
                {
                    "signature_and_body": "test('sanitizeInput fails on malformed attributes', () => {\n  const input = \"<img src='x' onerror='alert(1)' >\";\n  const output = sanitizeInput(input);\n  // Expecting it to remove the onerror event, but due to a bug, it fails.\n  expect(output).not.toBe('<img src=\\'x\\'>');\n});"
                }
            ]
        }
    ]
}

------------
