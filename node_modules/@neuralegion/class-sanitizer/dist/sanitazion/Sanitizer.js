"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sanitizer = void 0;
const tslib_1 = require("tslib");
const SanitizeTypes_1 = require("./SanitizeTypes");
const MetadataStorage_1 = require("../metadata/MetadataStorage");
const container_1 = require("../container");
const validator_1 = (0, tslib_1.__importDefault)(require("validator"));
const sanitizer_1 = require("sanitizer");
/**
 * Sanitizer performs sanitization of the given object based on its metadata.
 */
class Sanitizer {
    constructor() {
        this.metadataStorage = (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage);
    }
    /**
     * Performs sanitization of the given object based on annotations used in given object class.
     */
    sanitize(object) {
        this.metadataStorage
            .getTargetSanitizationMetadata(object.constructor)
            .filter(metadata => !!object[metadata.propertyName])
            .forEach(metadata => {
            const value = object[metadata.propertyName];
            if (metadata.each) {
                if (value instanceof Array) {
                    object[metadata.propertyName] = value.map((subValue) => this.sanitizeValue(subValue, object, metadata));
                }
            }
            else {
                object[metadata.propertyName] = this.sanitizeValue(value, object, metadata);
            }
        });
    }
    /**
     * Performs sanitization of the given object based on annotations used in given object class.
     * Performs in async-style, useful to use it in chained promises.
     */
    async sanitizeAsync(object) {
        return new Promise(ok => {
            setImmediate(() => this.sanitize(object));
            ok(object);
        });
    }
    /**
     * Strips unsafe tags and attributes from html.
     */
    secure(str) {
        if (typeof str !== 'string') {
            return str;
        }
        return (0, sanitizer_1.sanitize)(str);
    }
    /**
     * Remove characters that appear in the blacklist. The characters are used in a RegExp and so you will need to
     * escape some chars, e.g @Blacklist('\\[\\]')
     */
    blacklist(str, chars) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.blacklist(str, chars);
    }
    /**
     * Replace <, >, &, ', " and / with HTML entities.
     */
    escape(str) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.escape(str);
    }
    /**
     * Trim characters from the left-side of the input.
     */
    ltrim(str, chars) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.ltrim(str, chars ? chars.join() : undefined);
    }
    /**
     * Canonicalize an email address.
     */
    normalizeEmail(str, allLowercase) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.normalizeEmail(str, { all_lowercase: allLowercase });
    }
    /**
     * Trim characters from the right-side of the input.
     */
    rtrim(str, chars) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.rtrim(str, chars ? chars.join() : undefined);
    }
    /**
     * Remove characters with a numerical value < 32 and 127, mostly control characters.
     * If keepNewLines is true, newline characters are preserved (\n and \r, hex 0xA and 0xD).
     * Unicode-safe in JavaScript.
     */
    stripLow(str, keepNewLines) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.stripLow(str, keepNewLines);
    }
    /**
     * Convert the input to a boolean.
     * Everything except for '0', 'false' and '' returns true. In strict mode only '1' and 'true' return true.
     */
    toBoolean(input, isStrict) {
        if (typeof input === 'string') {
            return validator_1.default.toBoolean(input, isStrict);
        }
        return !!input;
    }
    /**
     * Convert the input to a date, or null if the input is not a date.
     */
    toDate(input) {
        if (input instanceof Date) {
            return input;
        }
        return validator_1.default.toDate(input);
    }
    /**
     * Convert the input to a float.
     */
    toFloat(input) {
        if (typeof input === 'number') {
            return input;
        }
        return validator_1.default.toFloat(input);
    }
    /**
     * Convert the input to an integer, or NaN if the input is not an integer.
     */
    toInt(input, radix) {
        if (typeof input === 'number') {
            return input;
        }
        return validator_1.default.toInt(input, radix);
    }
    /**
     * Convert the input to a string.
     */
    toString(input) {
        return String(input);
    }
    /**
     * Trim characters (whitespace by default) from both sides of the input. You can specify chars that should be trimmed.
     */
    trim(str, chars) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.trim(str, chars ? chars.join() : undefined);
    }
    /**
     * Remove characters that do not appear in the whitelist.
     * The characters are used in a RegExp and so you will need to escape some chars, e.g. whitelist(input, '\\[\\]').
     */
    whitelist(str, chars) {
        if (typeof str !== 'string') {
            return str;
        }
        return validator_1.default.whitelist(str, chars);
    }
    toUpperCase(str) {
        if (typeof str !== 'string') {
            return str;
        }
        return str.toUpperCase();
    }
    toLowerCase(str) {
        if (typeof str !== 'string') {
            return str;
        }
        return str.toLowerCase();
    }
    nestedSanitization(value) {
        if (value instanceof Array) {
            value.forEach(subValue => this.sanitize(subValue));
        }
        else if (value instanceof Set) {
            value.forEach(subValue => this.sanitize(subValue));
        }
        else if (value instanceof Map) {
            value.forEach(subValue => this.sanitize(subValue));
        }
        else if (value instanceof Object) {
            this.sanitize(value);
        }
        return value;
    }
    // eslint-disable-next-line complexity
    sanitizeValue(value, object, metadata) {
        switch (metadata.type) {
            case SanitizeTypes_1.SanitizeTypes.BLACKLIST:
                return this.blacklist(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.ESCAPE:
                return this.escape(value);
            case SanitizeTypes_1.SanitizeTypes.SECURE:
                return this.secure(value);
            case SanitizeTypes_1.SanitizeTypes.LTRIM:
                return this.ltrim(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.NORMALIZE_EMAIL:
                return this.normalizeEmail(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.RTRIM:
                return this.rtrim(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.STRIP_LOW:
                return this.stripLow(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.TO_BOOLEAN:
                return this.toBoolean(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.TO_DATE:
                return this.toDate(value);
            case SanitizeTypes_1.SanitizeTypes.TO_FLOAT:
                return this.toFloat(value);
            case SanitizeTypes_1.SanitizeTypes.TO_INT:
                return this.toInt(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.TO_STRING:
                return this.toString(value);
            case SanitizeTypes_1.SanitizeTypes.TRIM:
                return this.trim(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.WHITELIST:
                return this.whitelist(value, metadata.constraints[0]);
            case SanitizeTypes_1.SanitizeTypes.TO_LOWER_CASE:
                return this.toLowerCase(value);
            case SanitizeTypes_1.SanitizeTypes.TO_UPPER_CASE:
                return this.toUpperCase(value);
            case SanitizeTypes_1.SanitizeTypes.NESTED:
                return this.nestedSanitization(value);
            case SanitizeTypes_1.SanitizeTypes.CUSTOM_SANITIZATION: {
                const constraints = metadata.constraintCls
                    ? this.metadataStorage.getTargetSanitizationConstraints(metadata.constraintCls)
                    : [];
                const sanitizers = constraints.map((sanitizerMetadata) => {
                    const sanitizationArgs = {
                        value,
                        object,
                        targetName: object.constructor
                            ? object.constructor.name
                            : undefined,
                        property: metadata.propertyName,
                        constraints: metadata.constraints
                    };
                    return [sanitizerMetadata.instance, sanitizationArgs];
                });
                return sanitizers.reduce((result, [sanitizer, sanitizationArgs]) => sanitizer.sanitize(result, sanitizationArgs), value);
            }
            default:
                throw Error(`Wrong sanitization type is supplied ${metadata.type} for value ${value}`);
        }
    }
}
exports.Sanitizer = Sanitizer;
//# sourceMappingURL=Sanitizer.js.map