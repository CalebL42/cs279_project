"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataStorage = void 0;
class MetadataStorage {
    constructor() {
        this.sanitizationMetadata = [];
        this.constraintMetadata = [];
    }
    get hasSanitizationMetadata() {
        return !!this.sanitizationMetadata.length;
    }
    addSanitizationMetadata(metadata) {
        this.sanitizationMetadata.push(metadata);
    }
    addConstraintMetadata(metadata) {
        this.constraintMetadata.push(metadata);
    }
    groupByPropertyName(metadata) {
        const grouped = {};
        metadata.forEach(item => {
            if (!grouped[item.propertyName]) {
                grouped[item.propertyName] = [];
            }
            grouped[item.propertyName].push(item);
        });
        return grouped;
    }
    getTargetSanitizationMetadata(targetConstructor) {
        const originalMetadata = this.sanitizationMetadata.filter(metadata => metadata.target === targetConstructor);
        const inheritedMetadata = this.sanitizationMetadata.filter(metadata => {
            if (typeof metadata.target === 'string') {
                return false;
            }
            if (metadata.target === targetConstructor) {
                return false;
            }
            return (targetConstructor.prototype instanceof metadata.target ||
                !(metadata.target instanceof Function));
        });
        const uniqueInheritedMetadata = inheritedMetadata.filter(item => !originalMetadata.find(originalMeta => originalMeta.propertyName === item.propertyName &&
            originalMeta.type === item.type));
        return originalMetadata.concat(uniqueInheritedMetadata);
    }
    getTargetSanitizationConstraints(target) {
        return this.constraintMetadata.filter(metadata => metadata.target === target);
    }
}
exports.MetadataStorage = MetadataStorage;
//# sourceMappingURL=MetadataStorage.js.map