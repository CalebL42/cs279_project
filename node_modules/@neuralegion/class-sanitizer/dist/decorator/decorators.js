"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SanitizeNested = exports.ToUpperCase = exports.ToLowerCase = exports.Whitelist = exports.Trim = exports.ToString = exports.ToInt = exports.ToFloat = exports.ToDate = exports.ToBoolean = exports.StripLow = exports.Rtrim = exports.NormalizeEmail = exports.Ltrim = exports.Secure = exports.Escape = exports.Blacklist = exports.Sanitize = exports.SanitizerConstraint = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const MetadataStorage_1 = require("../metadata/MetadataStorage");
const SanitizeTypes_1 = require("../sanitazion/SanitizeTypes");
const container_1 = require("../container");
const ConstraintMetadata_1 = require("../metadata/ConstraintMetadata");
const SanitizationMetadata_1 = require("../metadata/SanitizationMetadata");
/**
 * Decorator used to register custom sanitizer.
 */
function SanitizerConstraint(options) {
    return (target) => {
        const isAsync = options && options.async;
        let name = options && options.name ? options.name : target.name;
        if (!name) {
            name = name
                .replace(/\.?([A-Z]+)/g, (_, y) => '_' + y.toLowerCase())
                .replace(/^_/, '');
        }
        const metadata = new ConstraintMetadata_1.ConstraintMetadata(target, name, isAsync);
        (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addConstraintMetadata(metadata);
    };
}
exports.SanitizerConstraint = SanitizerConstraint;
function Sanitize(constraintCls, constraintsOrSanitizationOptions, maybeSanitizationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.CUSTOM_SANITIZATION,
            target: object.constructor,
            propertyName,
            constraintCls,
            constraints: constraintsOrSanitizationOptions instanceof Array
                ? constraintsOrSanitizationOptions
                : undefined,
            sanitizationOptions: !(constraintsOrSanitizationOptions instanceof Array)
                ? constraintsOrSanitizationOptions
                : maybeSanitizationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Sanitize = Sanitize;
/**
 * Remove characters that appear in the blacklist. The characters are used in a RegExp and so you will need to
 * escape some chars, e.g @Blacklist('\\[\\]')
 */
function Blacklist(chars, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.BLACKLIST,
            target: object.constructor,
            propertyName,
            constraints: [chars],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Blacklist = Blacklist;
/**
 * Replace <, >, &, ', " and / with HTML entities.
 */
function Escape(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.ESCAPE,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Escape = Escape;
/**
 * Strips unsafe tags and attributes from html.
 */
function Secure(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.SECURE,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Secure = Secure;
/**
 * Trim characters from the left-side of the input.
 */
function Ltrim(chars, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.LTRIM,
            target: object.constructor,
            propertyName,
            constraints: [chars],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Ltrim = Ltrim;
/**
 * Canonicalize an email address.
 */
function NormalizeEmail(lowercase, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.NORMALIZE_EMAIL,
            target: object.constructor,
            propertyName,
            constraints: [lowercase],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.NormalizeEmail = NormalizeEmail;
/**
 * Trim characters from the right-side of the input.
 */
function Rtrim(chars, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.RTRIM,
            target: object.constructor,
            propertyName,
            constraints: [chars],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Rtrim = Rtrim;
/**
 * Remove characters with a numerical value < 32 and 127, mostly control characters.
 * If keepNewLines is true, newline characters are preserved (\n and \r, hex 0xA and 0xD).
 * Unicode-safe in JavaScript.
 */
function StripLow(keepNewLines, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.STRIP_LOW,
            target: object.constructor,
            propertyName,
            constraints: [keepNewLines],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.StripLow = StripLow;
/**
 * Convert the input to a boolean.
 * Everything except for '0', 'false' and '' returns true. In strict mode only '1' and 'true' return true.
 */
function ToBoolean(isStrict, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_BOOLEAN,
            target: object.constructor,
            propertyName,
            constraints: [isStrict],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToBoolean = ToBoolean;
/**
 * Convert the input to a date, or null if the input is not a date.
 */
function ToDate(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_DATE,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToDate = ToDate;
/**
 * Convert the input to a float.
 */
function ToFloat(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_FLOAT,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToFloat = ToFloat;
/**
 * Convert the input to an integer, or NaN if the input is not an integer.
 */
function ToInt(radix, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_INT,
            target: object.constructor,
            propertyName,
            constraints: [radix],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToInt = ToInt;
/**
 * Convert the input to a string.
 */
function ToString(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_STRING,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToString = ToString;
/**
 * Trim characters (whitespace by default) from both sides of the input. You can specify chars that should be trimmed.
 */
function Trim(chars, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TRIM,
            target: object.constructor,
            propertyName,
            constraints: [chars],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Trim = Trim;
/**
 * Remove characters that do not appear in the whitelist.
 * The characters are used in a RegExp and so you will need to escape some chars, e.g. whitelist(input, '\\[\\]').
 */
function Whitelist(chars, annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.WHITELIST,
            target: object.constructor,
            propertyName,
            constraints: [chars],
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.Whitelist = Whitelist;
function ToLowerCase(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_LOWER_CASE,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToLowerCase = ToLowerCase;
function ToUpperCase(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.TO_UPPER_CASE,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.ToUpperCase = ToUpperCase;
/**
 * Indicates if nested object should be sanitized as well.
 */
function SanitizeNested(annotationOptions) {
    return (object, propertyName) => {
        const args = {
            type: SanitizeTypes_1.SanitizeTypes.NESTED,
            target: object.constructor,
            propertyName,
            sanitizationOptions: annotationOptions
        };
        return (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).addSanitizationMetadata(new SanitizationMetadata_1.SanitizationMetadata(args));
    };
}
exports.SanitizeNested = SanitizeNested;
//# sourceMappingURL=decorators.js.map