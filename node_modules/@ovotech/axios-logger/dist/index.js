"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startHeader = 'X-Request-Started';
exports.redactHeader = 'X-Redact-Log';
const redactPath = (path, obj) => {
    const [current, ...rest] = path;
    return current === '*' && Array.isArray(obj)
        ? obj.map(item => redactPath(rest, item))
        : obj[current]
            ? { ...obj, [current]: rest.length ? redactPath(rest, obj[current]) : '<Removed>' }
            : obj;
};
const defaultRedact = ['requestBody', 'uri', 'params', 'responseBody'];
exports.redactPaths = (paths, object) => paths.reduce((current, path) => redactPath(path.split('.'), current), object);
exports.getMeta = (response) => {
    const { url: uri, data, params, method, headers } = response.config;
    const { data: responseBody, status } = response;
    const requestBody = data === undefined ? undefined : JSON.parse(data);
    const responseTime = headers[exports.startHeader] ? new Date().getTime() - headers[exports.startHeader].getTime() : undefined;
    const meta = { uri, method, requestBody, responseBody, params, status, responseTime };
    return exports.redactPaths(headers[exports.redactHeader] ? headers[exports.redactHeader].split(',').map((path) => path.trim()) : defaultRedact, meta);
};
exports.axiosLogger = (log) => ({
    request: {
        onFulfilled: (config) => ({
            ...config,
            headers: {
                ...config.headers,
                [exports.startHeader]: config.headers[exports.startHeader] || new Date(),
            },
        }),
    },
    response: {
        onFulfilled: (response) => {
            log('info', exports.getMeta(response), response.config);
            return response;
        },
        onRejected: (error) => {
            if (error.response) {
                const { responseBody, ...meta } = exports.getMeta(error.response);
                log('error', meta, error.config);
            }
            return Promise.reject(error);
        },
    },
});
//# sourceMappingURL=index.js.map